---
title: "tube_selection"
author: "Jan Wouters"
date: "16 juli 2019"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	eval = FALSE,
	dpi = 300,
	include = FALSE
)
options(stringsAsFactors = FALSE)
# library(plyr)
library(raster)
library(tidyverse)
library(stringr)
library(knitr)
library(sf)
library(git2rdata)
library(lubridate)
opts_chunk$set(
  echo = FALSE,
  dpi = 300
)
# install watina-package branch develop_fv
# remotes::install_github("inbo/watina",
#                         ref = "develop_fv")
library(watina)
?watina

# install n2khab-package
# remotes::install_github("inbo/n2khab",
#                         build_opts = c("--no-resave-data", "--no-manual"))
library(n2khab)

# source("../../n2khab/R/read_habitatdata.R")
# source("../../n2khab/R/read_types.R")
# inladen van n2khab-functions (workaround for loading error package)
# path_to_n2khabR <- "../../n2khab/R/"
# functions_in_n2khabR <- list.files(path = path_to_n2khabR, pattern = "R")
# path_function_in_n2khabR <- paste0(path_to_n2khabR, functions_in_n2khabR)
# path_function_in_n2khabR <- setNames(path_function_in_n2khabR,
#          make.names(gsub("*.R$", "", functions_in_n2khabR)))
# list2env(
#   lapply(path_function_in_n2khabR,
#          source),
#   envir = .GlobalEnv)
# 
# source("./R/read_types_local.R")
# source("./R/read_textdata_local.R")
```
# Inlezen habitatkaart

```{r loading habitatmap, include=FALSE}
habpath <- "./data/local/n2khab-binaire-databronnen"
habfile <- "20_processed/habitatmap_stdized/habitatmap_stdized.gpkg"


habitatmap_stdized <- read_habitatmap_stdized(path = habpath)

habmap_polygons <- habitatmap_stdized$habitatmap_polygons

habmap_patches <- habitatmap_stdized$habitatmap_patches

types <- read_types(lang = "nl")

habmap_patches <- habmap_patches %>%
    mutate( polygon_id = as.factor(.data$polygon_id),
            patch_id = as.numeric(.data$patch_id),
            certain = .data$certain == 1,
            type = factor(.data$type,
                          levels = levels(types$type)
                          )
            )

```

# Inlezen meetnetdefinities Natura 2000 monitoring

Voor elk Natura 2000 meetnet is gedefinieerd welke habitattypen en rbb's daarin worden meegenomen.
Voor het meetnet voor de milieudruk 'verdroging via grondwater' (in de meetnetten natuurlijk milieu) betreft het grondwatergevoede habitattypen (ggHT).
Deze ggHT worden opgedeeld in 5 habitattypegroepen.
Voor het droogtemeetnet wordt deze 5-delige indeling gebruikt.  
HTgroep 5 bevat uitsluitend HT die zodanig breed gedefinieerd zijn dat ze op sommige locaties grondwatergevoed zijn, maar soms (meestal) niet. De vraag is of en indien ja hoe we dan die grondwatergevoede locaties kunnen selecteren.  
De HTgroepen lenen zich heel goed om een stratificatie uit te voeren op basis van de verwachte responssnelheid van een locatie op droogte. 
De permanent gevoede locaties (HT-groep 1) zullen naar verwachting trager reageren dan de tijdelijk of zwak gevoede locaties. 
Door een stratificatie over de HT-groepen toe te passen kan een zekere (nog af te spreken) balans worden verzekerd. 

```{r loading environmental schemes, echo=FALSE}
# read_schemes_local(path = "../../n2khab/inst/textdata")
gw_types <- read_scheme_types() %>%
    filter(scheme == "GW_05.1_terr") %>%
    arrange(typegroup) %>%
    mutate(groupnr = as.integer(str_sub(typegroup, -1))) %>% 
    select(type, groupnr)

```

# Verspreiding van de verdrogingsgevoelige typen in Vlaanderen volgens de habitatkaart.

```{r habitat selection, echo=FALSE}
habmap_patches_gw <- habmap_patches %>% 
  inner_join(gw_types, by = c("type" = "type"))
habmap_polygons_gw <- habmap_polygons %>% 
  inner_join(habmap_patches_gw %>% dplyr::select(-code_orig), by = "polygon_id")

```

# Opgave van de grondwater-meetpunten (Watina-databank) die gelegen zijn in een verdrogingsgevoelig type.  

Hierbij werd met een zoekstraal van 10 meter rond een meetpunt gewerkt.
```{r loading and selecting tubes watina, echo=FALSE}
watina <- connect_watina()

?watina
?selectlocs_xg3
?get_locs
# debugonce(get_locs)
tubes_hab <- get_locs(watina, mask = habmap_polygons_gw, join_mask = TRUE, buffer = 10, loc_type = "P", loc_validity = c("VLD", "ENT"), collect = TRUE)
str(tubes_hab)

# een peilbuis kan meerdere keren voorkomen, wanneer de pb in een bwk-complex ligt. We kunnen ze groeperen als de verschillende eenheden tot eenzelfde gw-groep behoren.
test <- tubes_hab %>% 
  group_by(loc_code, polygon_id, groupnr) %>% 
  summarise(phab_gw = sum(phab),
            aantal =  n()) %>% 
  ungroup()
DBI::dbDisconnect(watina)

```

```{r watina lokaal, eval=FALSE, include=FALSE}

loc_type <- "P"
loc_validity <- c("VLD", "ENT")
max_filterdepth <- 3
buffer <- 10
join_mask <- TRUE
locs <-
        tbl(watina, "vwDimMeetpunt") %>%
        filter(MeetpuntTypeCode %in% loc_type,
               MeetpuntStatusCode %in% loc_validity
               ) %>%
        left_join(tbl(watina, "vwDimGebied") %>%
                      dplyr::select(GebiedWID,
                             GebiedCode,
                             GebiedNaam),
                  by = "GebiedWID")
# 
#     if (!is.null(loc_vec)) {
#         locs <-
#             locs %>%
#             filter(.data$MeetpuntCode %in% loc_vec)
#     }
# 
#     if (!is.null(area_codes)) {
#         locs <-
#             locs %>%
#             filter(.data$GebiedCode %in% area_codes)
#     }
# 
#     if (!is.null(bbox)) {
#         bbox_xmin <- unname(bbox["xmin"])
#         bbox_xmax <- unname(bbox["xmax"])
#         bbox_ymin <- unname(bbox["ymin"])
#         bbox_ymax <- unname(bbox["ymax"])
#         locs <-
#             locs %>%
#             filter(.data$MeetpuntXCoordinaat >= bbox_xmin,
#                    .data$MeetpuntXCoordinaat <= bbox_xmax,
#                    .data$MeetpuntYCoordinaat >= bbox_ymin,
#                    .data$MeetpuntYCoordinaat <= bbox_ymax)
#     }
locs_lokaal <- locs %>% collect()
locs_vervolg_lokaal <-
        locs %>%
        left_join(tbl(watina, "vwDimPeilpunt") %>%
                      dplyr::select(MeetpuntWID,
                             PeilpuntStatusCode,
                             PeilbuisLengte,
                             ReferentieNiveauMaaiveld) %>%
                      filter(PeilpuntStatusCode %in% c("VLD",
                                                       "ENT",
                                                       "CLD")),
                  by = "MeetpuntWID")  %>%
        filter(MeetpuntTypeCode == "P" &
                   (PeilbuisLengte - ReferentieNiveauMaaiveld) <=
                     max_filterdepth |
                   MeetpuntTypeCode != "P"
               )   %>%
        dplyr::select(loc_wid = MeetpuntWID,
               loc_code = MeetpuntCode,
               area_code = GebiedCode,
               area_name = GebiedNaam,
               x = MeetpuntXCoordinaat,
               y = MeetpuntYCoordinaat,
               loc_validitycode = MeetpuntStatusCode,
               loc_validity = MeetpuntStatus,
               loc_typecode = MeetpuntTypeCode,
               loc_typename = MeetpuntType) %>% 
        distinct %>%
        arrange(area_code,
                loc_code) %>% 
      collect()
mask <- habmap_polygons_gw
    if (!is.null(mask)) {

        nr_dropped_locs <-
            locs_vervolg_lokaal %>%
            filter(is.na(x) | is.na(y)) %>%
            count %>%
            collect() %>%
            .$n 


        if (nr_dropped_locs > 0) {
            warning("Dropped ",
                    nr_dropped_locs,
                    " locations from which x or y coordinates were missing.")
        }

        locs <-
            locs_vervolg_lokaal %>%
            dplyr::select(-loc_wid) %>%
            filter(!is.na(x), !is.na(y)) %>%
            collect %>%
            as_points

        if (buffer != 0) {
            mask_expand <-
                mask %>%
                st_buffer(dist = buffer)
        } else {
            mask_expand <-
                mask
        }

        if (join_mask == FALSE) {

            locs <-
                locs %>%
                st_join(mask_expand,
                        left = FALSE) %>%
                st_drop_geometry

        } else {

            locs <-
                locs %>%
                .[mask_expand, ] %>% 
                st_drop_geometry

        }

    }

    # if (collect & is.null(mask)) {
    #     locs <-
    #         locs %>%
    #         select(-.data$loc_wid) %>%
    #         collect
    # }
```

# Ontwerp van een meetnet

Het basisidee van het meetnet is om zo veel mogelijk een ruimtelijk gebalanceerd en vooraf gekozen aantal meetpunten te selecteren. 
We kunnen geen zuiver ruimtelijk gebalanceerde set opbouwen. 
Een dergelijke set zou kunnen opgebouwd worden door een overlay te maken van de verspreiding van de HT-groepen met een fijn GTRS raster. 
In een GTRS-raster vormen een willekeurig gekozen subset van opeenvolgende genummerde punten steeds een ruimtelijk gebalanceerde set. 
Echter de kans dat zich op een dergelijk punt een bestaand grondwatermeetpunt bevindt is weinig realistisch.

Om toch een zo goed mogelijk ruimtelijk gebalanceerde spreiding te garanderen wordt Vlaanderen opgedeeld in een raster van cellen van een bepaalde gelijke grootte. 
De keuze van celgrootte (en dus het aantal) cellen is bepaald door de ingeschatte grootte van het meetnet (en de minimale afstand tussen twee meetpunten). 
Hoe kleiner de celgrootte, hoe beter de ruimtelijke balans is, omdat men minder vrij is om een locatie te kiezen.  
We werken gestratificeerd volgens de 5-delige indeling van HT-groepen. 
Zo verzekeren we dat elke HT-groep voldoende gemonitord zal worden.

Niet elke cel is even belangrijk voor de monitoring van een HT-groep, want de oppervlakte van ggHT verschilt van cel tot cel. 
Het heeft geen zin om in een raster een meetpunt te voorzien voor een HT-groep indien die groep daar niet in aanwezig is.  

De raster-cellen zullen dus niet obv GRTS geselecteerd worden, maar in verhouding tot de relatieve oppervlakte van een HT-groep dat het bevat. 
Hiertoe kan als maat de gemiddelde oppervlakte van een HT-groep per gewenst meetpunt gebruikt worden. 

```{r meetnet ontwerp}
# gewenst_totaal_aantal_meetpunten
tot_n_tub <- 100
# aantal stratificatielagen
aantal_strat <- 5

#importeren van GRTS-lagen, voor het meetnet kiezen we level 8: cellen van 8192 m
datapath <- "./data/local/n2khab-binaire-databronnen"


read_GRTSmh(datapath, brick = TRUE)
#level 4 : resolutie = 512m, level 5 :  1024m, level 6 = 2048, level 7= 4096, level 8 = 8192)
# test header 1 ----
# read_GRTSmh_diffres(datapath, level = 7)

# raster_meetnet <- read_GRTSmh_diffres(datapath, level = 9)
# raster_meetnet_64m <- read_GRTSmh_diffres(datapath, level = 1)
# 
# habmap_raster_group1 <- rasterize(habmap_polygons_gw %>% filter(groupnr == 1),raster_meetnet_64m,field = "groupnr", fun = sum, background = 0)
# habmap_raster_group2 <- rasterize(habmap_polygons_gw %>% filter(groupnr == 2),raster_meetnet_64m,field = "groupnr", fun = 'last' , background = 0)
# 
# test <- cellStats(habmap_raster_group2, max)
# plot(habmap_raster_group1)
# plot(habmap_raster_group2)
# plot(raster_meetnet)
# plot(habmap_polygons_gw %>% filter(groupnr == 2) %>% select(groupnr))
# 
# writeRaster(habmap_raster_group2, "./data/local/processed/habmap_raster_group2.grd", format = "raster")

raster_meetnet_poly <- read_GRTSmh_diffres(datapath, level = 8, polygon = TRUE)
#welke crs?
st_crs(habmap_polygons_gw)
st_crs(raster_meetnet_poly)


plot(raster_meetnet_poly)

#check op unieke celwaarden
check <- raster_meetnet_poly %>% st_drop_geometry() %>% distinct(value)
#van bepaalde cellen zijn er dus meerdere polygonen, dit zijn rasters die door de gewestgrens verdeeld werden (bijv. streek van Baarle-Nassau) 

raster_meetnet_poly <- raster_meetnet_poly %>% 
  rename(rasterid =  value)

# overlay maken van de habitatkaart (enkel van HT-groepen) en het GTRS-raster (level8)
habmap_gw_raster_overlay <- habmap_polygons_gw %>% 
  st_intersection(raster_meetnet_poly)

habmap_gw_raster_overlay <- habmap_gw_raster_overlay %>% 
    mutate(opp = as.integer(st_area(habmap_gw_raster_overlay))) 

#oppervlakte gw-groep per rastercel
raster_gw_opp <- habmap_gw_raster_overlay %>% 
  st_drop_geometry() %>% 
  group_by(rasterid,groupnr) %>% 
  summarise(opp_gw_cel = sum(opp*phab/100)) %>% 
  ungroup()
# view(raster_gw_opp)
raster_gw_opp

#totale opp van een gw-groep
gw_opp <- raster_gw_opp %>% 
  group_by(groupnr) %>% 
  summarise(opp_gw = sum(opp_gw_cel)) %>% 
  ungroup()

#benodigde oppervlakte van een gw-groep in een cel om hierin 1 meetpunt aan te duiden
#hier wordt voor de eenvoud nog een gelijke verdeling over de (5) strata genomen. Wijzigingen zijn mogelijk.

#invoeren van een correctiefactor om het wegvallen van meetpunten bij afronding naar een geheel getal te compenseren. Deze factor wordt routinematig berekend.

minaantal_tub_group <- tot_n_tub/aantal_strat
min_aantal_tub = data.frame("groupnr" = 1:5, minaantal = seq(20,20,length.out = 5))

for (group in seq(1,aantal_strat)) {
  # group <- 5
  minaantal_tub_group <- min_aantal_tub[min_aantal_tub$groupnr == group,"minaantal"]
  aantal_tub_group <- 0
  corrafronding <- 1
  while (aantal_tub_group < minaantal_tub_group) {
    gw_opp <- gw_opp %>% 
      mutate(minopp = opp_gw/minaantal_tub_group * corrafronding)
    gw_opp
    
    #berekening van het aantal meetpunten per cel

    aantal_meetpunten_cel_group <- raster_gw_opp %>% 
      inner_join(gw_opp, by = "groupnr") %>% 
      mutate(gew_aantal_meetptn = opp_gw_cel/minopp) %>% 
      arrange(desc(gew_aantal_meetptn))
    
    aantal_meetpunten_cel_group
    
    aantal_meetpunten_cel_group <- aantal_meetpunten_cel_group %>% 
      filter(gew_aantal_meetptn >= 0.5, groupnr == group) %>% 
      mutate(gew_aantal_meetptn_afgerond = round(gew_aantal_meetptn+0.01, digits = 0) )
    
    df <- aantal_meetpunten_cel_group %>% filter(groupnr == group)  %>% 
      summarise(aantal  = sum(gew_aantal_meetptn_afgerond)) %>% 
      ungroup() %>% 
      summarise(minaantal = min(aantal)) %>% 
      ungroup() 
    aantal_tub_group <- as.integer(df[1])
    corrafronding <- corrafronding - 0.01 
  }
  if (group == 1){
    aantal_meetpunten_cel <- aantal_meetpunten_cel_group
  } else {
    aantal_meetpunten_cel <- bind_rows(aantal_meetpunten_cel, aantal_meetpunten_cel_group)
  }
}
# df <- aantal_meetpunten_cel %>% group_by(groupnr)  %>% 
#    summarise(aantal  = sum(gew_aantal_meetptn_afgerond)) %>% 
#    ungroup()
# df

# Enkel bij groep 3 komt het opp-gerelateerd aantal meetptn overeen met het vereiste aantal. Voor de overige gw-groepen is het opp-gerelateerd aantal hoger. 
# Twv de ruimtelijke balancering wordt bij voorkeur voor de gw-groepen waar het minimum aantal wordt overschreden, dit aantal tot het minimum teruggebracht door de hokken te selecteren op basis van hun rangorde in het GTRS-raster. Men kan echter ook de koppeling met geschikte watina-meetptn afwachten. 
# We doen hier eerst de aanbevolen GRTS-strategie
# if (df[df$groupnr == 1,"aantal"] > minaantal_tub_group) {}
# 
# sel_raster <- raster_meetnet_poly %>% 
#   st_drop_geometry()  %>% 
#   inner_join(raster_gw_opp, by = "rasterid") %>% 
#   inner_join(aantal_meetpunten_cel_group, by =  c("rasterid", "groupnr")) %>% 
#   inner_join(min_aantal_tub, by = "groupnr") %>% 
#   group_by(groupnr) %>% 
#   distinct(rasterid, minaantal) %>% 
#   top_n(minaantal, rasterid)
# 
# sel_raster_meetnet <- raster_meetnet_poly %>% 
#   inner_join(sel_raster, by = "rasterid")
# 
# plot(sel_raster_meetnet)


#cellen selecteren met een gewenst meetpunt, een cel kan voor meerdere HT-groepen geselecteerd zijn
sel_raster_meetnet <- raster_meetnet_poly %>%
  inner_join(raster_gw_opp, by = "rasterid") %>%
  inner_join(aantal_meetpunten_cel %>% 
               select(rasterid, groupnr, gew_aantal_meetptn_afgerond), 
             by =  c("rasterid", "groupnr")) %>% 
  rename(gew_aantal_meetptn = gew_aantal_meetptn_afgerond)


# voorbeeld van rasters van HT-groep 1 (permanent nat)
plot(sel_raster_meetnet %>% filter(groupnr == 1))


```

# Opzoeken van Watina-meetpunten in de geselecteerde cellen ('sel-cellen')

```{r tubes (watina) in selected cells}
tubes_in_raster <- tubes_hab %>% 
  select(-11:-16) %>% 
  inner_join(habmap_gw_raster_overlay %>% 
               st_drop_geometry(), by = "polygon_id") %>% 
  inner_join(sel_raster_meetnet %>% 
               select(rasterid, groupnr) %>% 
               st_drop_geometry(), by = c("rasterid", "groupnr"))

tubes_in_raster
```
# Zijn er sel-cellen zonder watina-meetpunt?

```{r tubeless selcells, warning== FALSE}
sel_zonder_meetpunt <- sel_raster_meetnet %>% 
  anti_join(tubes_in_raster, group_by = c("rasterid", "groupnr")) %>% 
  distinct(rasterid, groupnr) %>% 
  arrange(rasterid)

plot(sel_zonder_meetpunt %>% select(groupnr) %>% filter(groupnr == 2))

sel_zonder_meetpunt_tabel <- sel_raster_meetnet %>% 
  anti_join(tubes_in_raster, group_by = c("rasterid", "groupnr")) %>% 
  st_drop_geometry() %>% 
  distinct(rasterid, groupnr) %>% 
  arrange(rasterid)

sel_zonder_meetpunt_tabel %>%
  group_by(groupnr ) %>% 
  summarise('aantal cellen zonder meetpunt' = n())


```
Ja, een 'r as.integer(sel_zonder_meetpunt_tabel %>% count %>% magrittr::extract(1,1))'-tal

# Selectie van meetpunten met een goede tijdreeks binnen de geselecteerde cellen

```{r selection tubes with good time-series in selected cells}
watina <- connect_watina()


tubes_xg3 <- tubes_in_raster %>% 
    get_xg3(watina, startyear = year(now()) - 15, vert_crs = "local", truncated =  TRUE, collect = TRUE)

tubes_xg3_avail <- tubes_xg3 %>% 
    eval_xg3_avail( xg3_type = "L")
# debugonce(eval_xg3_series)
tubes_xg3_eval <-   tubes_xg3 %>%
  eval_xg3_series(xg3_type = c("L"),
                  max_gap = 2,
                  min_dur = 5)

# sessioninfo::session_info()

DBI::dbDisconnect(watina)
```

```{r join tubes with a xg3 on the raster_survey}

sel_raster_xg3 <- sel_raster_meetnet %>% 
  left_join(tubes_in_raster %>% 
              distinct(loc_code, rasterid, groupnr), by = c("rasterid", "groupnr")) %>% 
  left_join(tubes_xg3_eval, by = "loc_code") %>% 
  group_by(rasterid, groupnr, gew_aantal_meetptn) %>% 
  summarise(aantal_meetpunten = n(),
            aantal_series = sum(!is.na(series)),
            max_aantalmeetjaren = max(ser_nryears, na.rm =  TRUE))

  
sel_raster_xg3 %>% st_drop_geometry()
```
# koppeling van xg3-meetpunten aan de geselecteerde rastercellen

```{r eval=FALSE, include=FALSE}
write_vc(habmap_raster)
raster_meetnet_polyg <- st_as_sf(rasterToPolygons(raster_meetnet))
raster_meetnet_polyg <- st_transform(raster_meetnet_polyg, crs = 31370)
test <- intersect(raster_meetnet_polyg, habmap_polygons_gw)



st_crs(raster_meetnet_polyg)
ggplot(raster_meetnet_polyg ) +
  geom_sf() +
  scale_color_viridis_c(trans = "sqrt", alpha = .9) + 
  coord_sf(datum = sf::st_crs(31370))



st_crs(habmap_polygons_gw)
ggplot(habmap_polygons_gw %>% slice(100:300)) +
  geom_sf(aes(colour = groupnr)) +
  scale_color_viridis_c(trans = "sqrt", alpha = .9) + 
  coord_sf(datum = sf::st_crs(31370))

head(habmap_polygons_gw)

# library(stars)
# ggplot() +
#   geom_stars(data = test)
plot(raster_meetnet)
zoom(raster_meetnet, ext = drawExtent())
fromDisk(raster_meetnet)
hasValues(raster_meetnet)

# cells <- c(1:40000)
# r <- rasterFromCells(test, cells, values = FALSE)
# plot(r)

#random selectie van een aantal gebalanceerde rastercellen
set.seed(12345)
  #gewenst_totaal_aantal_meetpunten
tot_n_tub <- 100



aantal_strat <- 5

for (i in seq(1:aantal_strat)) {
  random_integer <- as.integer(runif(1, min  = 1, max = maxValue(raster_meetnet) - tot_n_tub))
  m <- c(0, random_integer - 1, 0, random_integer,  random_integer + (tot_n_tub/aantal_strat) - 1, 1, random_integer + (tot_n_tub/aantal_strat) - 1, maxValue(raster_meetnet), 0)
  rclmat <- matrix(m, ncol = 3, byrow = TRUE)
  rc <- reclassify(raster_meetnet, rclmat)  
  assign(paste0("raster_group", i), rc)
}
plot(raster_group3)
# reclassify the values into three groups 
# all values >= 0 and <= 0.25 become 1, etc.
m <- c(0, 60000, 0,  60000, 70000, 1)
rclmat <- matrix(m, ncol = 3, byrow=TRUE)
rc <- reclassify(test, rclmat)
plot(rc)
```


## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
