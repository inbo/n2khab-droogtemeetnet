
Figuur \@ref(fig:droogte-indicator-met-ci-figuur) is hiervan een grafische weergave.
De groene lijn in de figuur geeft het aantal dagen dat jaarlijks gemiddeld verwacht wordt.

Het grillige patroon van de indicator springt hierbij in het oog.
Een 'normaal' jaar is eerder uitzondering dan regel.
Als het droog is, is het ook vaak flink droog. 
Natte jaren zijn minder opvallend, omdat de droogte-indicator niet onder nul kan gaan.
Uitgezonderd voor het jaar 2018 zit er vrij weinig variatie in de hoogte van de pieken. 
Men ziet wel een wijziging in de frequentie ervan, met een toename vanaf rond 2000.
Dit wordt verder onderzocht in het onderzoek van de trend.

(ref:droogte-indicator-met-ci-figuur) Droogte-indicator met 95% betrouwbaarheid

```{r droogte-indicator-met-ci-figuur, fig.cap= "(ref:droogte-indicator-met-ci-figuur)"}
g <- ggplot(data = droogte_ind_j, aes(x = jaar, y = droogte_ind_j)) + 
  theme_inbo() +
  geom_ribbon(aes(ymin = lcl, ymax = ucl)) +
  geom_hline(yintercept = 365*0.05, color = "green", linetype = "dashed") +
  geom_line(color = "red", size = 0.5) + 
  labs (y = "aantal droge dagen") + 
  scale_x_continuous(n.breaks = nrow(droogte_ind_j)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
g
```

De formule van Rubin laat toe om in te schatten wat de kost is van het ontbreken van data op de betrouwbaarheid van het resultaat.
Onderstaande figuur (\@ref(fig:droogte-indicator-imput-fig)) toont het aandeel in de totale variatie ten gevolge van het schatten van ontbrekende gegevens. 
Dit is meestal meer dan 10% en kan tot 50% bedragen.
Er zit een duidelijke neerwaartse trend in.
Deze trend is te verklaren door de toegenomen meetintensiteit.

```{r droogte-indicator-imput-fig, fig.cap="Het aandeel van imputatie in de totale variatie van de droogte-indicator", message=FALSE}
g <- ggplot(data = droogte_ind_j_var, aes(x = jaar, y= rel_bijdrage_imput)) + 
  geom_line() + geom_smooth() + theme_inbo() +
  labs (y = "aandeel (%)") + 
  scale_x_continuous(n.breaks = nrow(droogte_ind_j)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
g
```

## De trend in de droogte-indicator {#h4-3:trend}

Bij een indicator is het verloop van de waarden nog belangrijker dan de absolute waarden an sich.
Zijn in onze de natuurgebieden de grondwaterpeilen ten gevolge van neerslagtekort aan het dalen ?

Om dit te kunnen nagaan bekijken we eerst de rollende gemiddelden. 

```{r rollend-gem-met-ci, include=FALSE}
dagen_droog_ma <- dagen_droog %>% 
  pivot_longer(cols = starts_with("dag_onder_p05."), names_to = "rollendgem", values_to = "waarde") %>% 
  mutate(tijdsvenster = as.integer(str_sub(rollendgem, 14 + 1,-1)),
        rollendgem = "dag_onder_p05.ma"
        ) %>% 
  pivot_wider(names_from = rollendgem, values_from = waarde)

droogte_ind_j_ma <- dagen_droog_ma %>% 
  group_by(jaar, tijdsvenster) %>% 
  summarise(droogte_ind_j = mean(dag_onder_p05.ma)
            ) %>% 
  ungroup()

droogte_ind_j_s <- dagen_droog_ma %>% 
  group_by(jaar, simulatienr, tijdsvenster) %>% 
  summarise(droogte_ind_j_s = mean(dag_onder_p05.ma),
            aantal = n(),
            dagen_droog_se = sd(dag_onder_p05.ma)/sqrt(aantal)
            ) %>% 
  ungroup()

droogte_ind_j_var <- droogte_ind_j_s %>% 
  inner_join(droogte_ind_j_ma) %>% 
  group_by(jaar, tijdsvenster) %>% 
  summarise(dagen_droog_gem_var = mean(dagen_droog_se^2),
            aantalsim= n(),
            imput_var = (1+1/aantalsim) * sum((droogte_ind_j_s - droogte_ind_j)^2/(aantalsim-1)),
            droogte_ind_j_var = dagen_droog_gem_var + imput_var
            ) %>% 
  ungroup() %>% 
  dplyr::select (-aantalsim)

droogte_ind_j_var <- droogte_ind_j_var %>% 
  mutate (rel_bijdrage_imput = round(imput_var/droogte_ind_j_var*100,0))


droogte_ind_j_ma <- droogte_ind_j_ma %>% 
  inner_join(droogte_ind_j_var %>% 
               dplyr::select(-starts_with(c("dagen", "imput", "rel")))) %>% 
  mutate(lcl = droogte_ind_j - 1.96*sqrt(droogte_ind_j_var),
         ucl = droogte_ind_j + 1.96*sqrt(droogte_ind_j_var)
         )

```

```{r rollend-gem-met-ci-vc, include=FALSE}
write_vc(droogte_ind_j_ma, file.path("data", "result", "droogte-indicator"), sorting = c("jaar", "tijdsvenster"), strict= FALSE)
```
Figuur \@ref(fig:rollend-gem-fig) geeft het effect weer van de verschillende tijdsvensters.
Op de figuren zijn de jaren met een onvolledig tijdsvenster lichter gekleurd, omdat voor deze jaren de berekening van het rollend gemiddelde niet helemaal vergelijkbaar is met de jaren waarvoor het rollend gemiddelde wel op basis van een volledig jaarvenster kon gebeuren.
Naarmate het tijdsvenster vergroot, wordt de lijn logischerwijze rechtlijniger. 
De trend vertoont een lichte stijging.
 
```{r rollend-gem-fig-save, fig.cap="rollend gemiddelde", message=FALSE, warning=FALSE, include=FALSE}
#plot van de trend
gplot <- plotma(droogte_ind_j_ma,"droogte_ind_j", 18)
png(paste0(file.path("data","result", "figures","dagen-droog-p05"),"-rollendgem",".png"), width = 1500, height = 1500, res = 150)
gplot
dev.off()
```
 
```{r rollend-gem-fig, fig.cap="De droogte-indicator (cfr. tijdsvenster = 0 jaar) en verschillende hiervan afgeleide rollende gemiddelden",  message=FALSE, warning=FALSE}
gplot
```


Daarna maken we een model op dat de variatie in de indicatorwaarden tracht te verklaren. 
In het model is de factor tijd één van de verklarende variabelen.
De andere verklarende factor is de locatie (de ene plaats kan een afwijkend gedrag vertonen t.o.v. een andere).
We onderzoeken hier alleen het tijdsaspect. 
Een mogelijke andere interessante vraag is of er regionale verschillen zijn tussen de waarden en waardoor deze dan  kunnen verklaard worden. 
Om deze vraag te kunnen beantwoorden is het huidige en voorziene meetnet echter minstens een orde te klein!

Voor de berekening van de trend doen we beroep op Bayesiaanse modeltechnieken.
Deze technieken laten toe om voorkennis over de data te gebruiken bij het modelleren. 
We passen dit principe toe bij de vorm van de curve die we aan de trendlijn willen geven.
Een model dat heel goed de data kan voorspellen zal ongeveer het grillige patroon volgen van de indicator. 
We hebben dan wel een heel goed model, alleen bekomen we zo weinig extra informatie of er nu een geleidelijke verandering aan de gang is.
Door uit te gaan of op te leggen dat de curve elk jaar niet veel mag veranderen, kunnen we de curve minder grillig laten zijn. 

Het instellen van deze 'smoothing' = het meer of minder grillig laten zijn van de trendlijn is een subjectief gegeven en steunt ook op trial en error van de keuze van de smoothing-parameters.  
De trendlijn is daarom te interpreteren als 'stel dat de toe- of afname (min of meer) rechtlijnig zou zijn, hoe zou die trendlijn er dan uitzien'.

```{r abs-indic-model-function-exploratory, eval=FALSE}
indic_abs_function <- function(modeldata, suffix= "", respons, percentile, indicatorname, standardised) {

  #instellen van de priors. Dit is 
  #prec.prior <- list(prec = list(param = c(0.001, 0.001)))
  
  #De instelling van de prior heeft een doorslaggevend effect op de vorm van de trendlijn. 
  #Geven we het model de vrijheid om een trendlijn te bepalen dan voegen we weinig apriori-kennis toe aan het model
  #Voor de random-walk van de tweede orde doen we dat via de prior voor de precisie. Deze bevat twee elementen: de standaarddeviatie en een alfa. Het eerste element geeft aan in welke mate we denken/willen dat de rw2 mag fluctueren en en de alfa de zekerheid die we daarover hebben. Wil je een quasi rechte lijn, dan moeten beide parameters klein ingesteld worden. Laat je ze vrij, dan kan de trend een grillig patroon gaan vertonen.
  prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.025, 0.001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.25, 0.001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.25, 0.95)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(2.5, 0.95)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(2.5, 0.001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.0025, 0.001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.0025, 0.99)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.0025, 0.0001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  prec.prior.mp <- list(theta = list(prior = "pc.prec", param = c(0.025, 0.95)))# list(theta = list(prec = list(param = c(0.001, 0.001)))) 
  model <- as.formula(paste(respons, "~", "f(jaar, model =", "'rw2', scale.model = TRUE,
                          hyper = prec.prior)+ f(meetpunt, model = 'iid', hyper = prec.prior.mp)", sep = " "))   
  # model <- as.formula(paste(respons, "~", "1 + jaar_factor + f(meetpunt, model = 'iid', hyper = prec.prior)", sep = " "))     
  suffix <- ifelse(suffix == "", "", paste0("_", suffix))
  resultname_stat <- paste0("indic_abs_p", percentile, suffix, "_jaar_stat", if (standardised == TRUE) ("_std"))
  resultname_fitted <- paste0("indic_abs_p", percentile, suffix, "_fitted", if (standardised == TRUE) ("_std"))
  if (percentile == "01") {
    reeks <- c(1:20) #1 model wou maar niet convergeren
  } else {
    reeks <- c(1:20)    
  }  
  teller <- 0
  for (i in reeks) {
    #i = 16
    mdata <- modeldata[modeldata$simulatienr == i,]
    jaren <- mdata %>% distinct(jaar) %>% mutate(simulatienr = i)
    
    #samenstellen van een tweeledig dataframe. De eerste 34 rijen (#jaren) zijn leeg en dienen om de gemiddelde waarden en de bijhorende fouten te berekenen. Het tweede deel dient om het model mee te bouwen
    mdata <- bind_rows(jaren, mdata)    
    # mdata[mdata[,respons] == 0,respons] <- 1e16
    print(i)    
    teller <- teller + 1
    I2 <- inla(model, 
                     control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
                     family = modelkeuze %>% filter(percentiel == percentile) %>% 
                              dplyr::pull(model), 
                     #Ntrials = aantaldagen_jaar,
                     data = mdata
    )

    # I2b <- inla(model,
    #            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
    #            family = "nbinomial",
    #            #Ntrials = aantaldagen_jaar,
    #            data = mdata
    # )
    # I2c <- inla(model,
    #             control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
    #             family = "zeroinflatednbinomial1",
    #             #Ntrials = aantaldagen_jaar,
    #             data = mdata,
    #             verbose = FALSE
    # )
    # I2d <- inla(model,
    #             control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
    #             family = "zeroinflatednbinomial0",
    #             #Ntrials = aantaldagen_jaar,
    #             data = mdata
    # )
    # de negatieve binomiale modellen gebruiken de logit-link
    #om de niet-getransformeerde waarden te krijgen moet men zowel de intercept als de coëfficiënten exponentiëren. Exp(standaardfout) heeft geen zin, maar het was moeilijker om deze uit te sluiten dan ze (verkeerdelijk) mee te nemen
    #summary(I2)
    # result_stat_i <-  I2$summary.random$jaar %>%
    #   mutate_at(names(I2$summary.random$jaar)[2:6], exp) %>%
    #   mutate_at(names(I2$summary.random$jaar)[2:6], function(x){x*exp(I2$summary.fixed$mean)}) %>%       mutate(simulatienr = i) %>%
    #   dplyr::select(-sd, -mode, -kld)
    
    #linear_predictor : deze is niet teruggetransformeteerd. We zijn hier alleen geïnteresseerd in de rijen met lege responsen: hier krijg je dan per jaar een gemiddelde predictie én de se.
    result_stat_i <- I2$summary.linear.predictor %>% 
      slice(1:nrow(jaren)) %>% 
      bind_cols(jaren) %>% 
      mutate(intercept = I2$summary.fixed$mean) %>% 
      dplyr::select(-mode, -kld)    
    #summary(I2b)  
    #modelkeuze %>% filter(percentiel == percentile) %>% dplyr::pull(model)

    # sum(log(I2$cpo$cpo))
    # sum(log(I2b$cpo$cpo))
    # sum(log(I2c$cpo$cpo))
    # sum(log(I2d$cpo$cpo))
    # # sum(log(I2_binom$cpo$cpo))
    # 
    # sum(log(I2$dic$dic))
    # sum(log(I2b$dic$dic))
    # sum(log(I2c$dic$dic))
    # sum(log(I2d$dic$dic))
    # 
    # sum(log(I2$waic$waic))
    # sum(log(I2b$waic$waic))
    # sum(log(I2c$waic$waic))
    # sum(log(I2d$waic$waic))
    # 
    # sum(I2$mlik)
    # sum(I2b$mlik)
    # sum(I2c$mlik)
    # sum(I2d$mlik)

    # names(inla.models()$likelihood)
    
    # # Assess overdispersion (variantie / aantal vrijheidsgraden ~ 1)
     # #voor binomiaal
     # Pi   <- I2b$summary.fitted.values[,"mean"]
     # ExpY <- Pi * mdata$aantaldagen_jaar
     # VarY <- Pi * mdata$aantaldagen_jaar * (1 - Pi)
     # E1   <- (mdata %>%
     #               dplyr::pull(!!indicatorname) - ExpY) / sqrt(VarY)
     # N    <- nrow(mdata)
     # p <- nrow(I2b$summary.fixed)
     # Dispersion <- sum(E1^2) / (N - p)
     # Dispersion
    
    # #voor poisson
    # Pi   <- I2c$summary.fitted.values[,"mean"]
    # ExpY <- Pi #* mdata$aantaldagen_jaar
    # VarY <- Pi #* mdata$aantaldagen_jaar * (1 - Pi)
    # E1   <- (mdata %>%
    #               dplyr::pull(!!indicatorname) - Pi) / sqrt(VarY)
    # N    <- nrow(mdata)
    # p <- nrow(I2c$summary.fixed)
    # Dispersion <- sum(E1^2) / (N - p)
    # Dispersion
    
    # #voor negatief binomiaal
    # Pi  <- I2$summary.fitted.values[,"mean"] [-(1:nrow(jaren))]
    # theta <- I2$summary.hyperpar[1,"mean"]
    # E1 <- (mdata %>% slice(-(1:nrow(jaren))) %>%
    #          dplyr::pull(!!indicatorname)  - Pi) / sqrt(Pi + Pi^2 / theta)
    # sum(E1^2) / (nrow(mdata) - 1)
    # 
    # Pi  <- I2b$summary.fitted.values[,"mean"]
    # theta <- I2b$summary.hyperpar[1,"mean"]
    # E1 <- (mdata %>% slice(-(1:nrow(jaren))) %>%
    #          dplyr::pull(!!indicatorname)  - Pi) / sqrt(Pi + Pi^2 / theta)
    # sum(E1^2) / (nrow(mdata) - 1)


    # 
    # Pi  <- I2c$summary.fitted.values[,"mean"]
    # theta <- I2c$summary.hyperpar[1,"mean"]
    # E1 <- (mdata %>%
    #          dplyr::pull(!!indicatorname)  - Pi) / sqrt(Pi + Pi^2 / theta)
    # sum(E1^2) / (nrow(mdata) - 1)
    # 
    # 
    # Pi  <- I2d$summary.fitted.values[,"mean"]
    # theta <- I2d$summary.hyperpar[1,"mean"]
    # E1 <- (mdata %>%
    #          dplyr::pull(!!indicatorname)  - Pi) / sqrt(Pi + Pi^2 / theta)
    # sum(E1^2) / (nrow(mdata) - 1)
    # 
    # # Pearson residuals
    # par(mfrow = c(1,1), mar = c(5,5,2,2), cex.lab = 1.5)
    # plot(x = Pi,
    #      y = E1,
    #      xlab = "Fitted values",
    #      ylab = "Pearson residuals")
    # abline(h = 0, lty = 2)
    # 
    # #names(inla.models()$likelihood)
    # 
    # # bekijk de gefitte waarden van het model
    # # Plot the fitted values
    # Fit1     <- I2$summary.fitted.values[,"mean"][-(1:nrow(jaren))]
    # Fit1.025 <- I2$summary.fitted.values$"0.025quant"[-(1:nrow(jaren))]
    # Fit1.975 <- I2$summary.fitted.values$"0.975quant"[-(1:nrow(jaren))]
    # # 
    # # Fit1     <- I2d$summary.fitted.values[,"mean"]
    # # Fit1.025 <- I2d$summary.fitted.values$"0.025quant"
    # # Fit1.975 <- I2d$summary.fitted.values$"0.975quant"
    # # 
    # check <- I2$summary.fitted.values[,"mean"][(1:nrow(jaren))] %>% bind_cols(jaren)
    # check2 <- mdata2 %>%
    #   group_by(jaar) %>%
    #   summarise(gemj = mean(Fitted1))
    # check <- check %>% inner_join(check2, by = "jaar")
    # write_csv(check, "check.csv")
    # result_stat_i2 <- result_stat_i2 %>%
    #   mutate(terug = inla.link.log(mean, inverse = TRUE))
    # #   #
    # # check <- I2$summary.random$meetpunt
    # #
    # # result_fitted_i
    # mdata2 <- mdata %>% slice(-(1:nrow(jaren)))
    # mdata2$Fitted1  <- Fit1
    # mdata2$Fit1.025 <- Fit1.025
    # mdata2$Fit1.975 <- Fit1.975
    # #gdata <- mdata %>% dplyr::select(!!respons, jaar, contains("Fit"))
    # p <- ggplot(data = mdata2, aes_string(y = respons, x = "jaar"))
    # p <- p + xlab("Jaar") + ylab(respons)
    # p <- p + theme(text = element_text(size = 15))
    # p <- p + geom_point(shape = 16, size = 2, col = "black")
    # p <- p + geom_line(aes(x = jaar, y = Fitted1))
    # p <- p + geom_ribbon(data = mdata2 %>% group_by(jaar) %>% summarise(ymax_data = max(Fit1.975), ymin_data = min(Fit1.025)), aes(x = jaar,
    #                          ymax = ymax_data,
    #                          ymin = ymin_data), inherit.aes = F,
    #                      fill = grey(0.5),
    #                      alpha = 0.4)
    # p <- p + theme(strip.text = element_text(size = 15))
    # p
    # summary(I2)
    # result_stat_i <-  I2$summary.random$jaar %>%
    #   mutate(simulatienr = i)
    #  result_stat_i <- result_stat_i %>%  rename (p0.025 = '0.025quant',
    #                              p975.5 = '0.975quant',
    #                              jaar =  ID)
    #  gplot <- ggplot(data = result_stat_i, aes(x = jaar, y = mean)) +
    #    geom_line(aes(x = jaar, y = p0.025), linetype = "longdash") +
    #    geom_ribbon(aes(x = jaar, ymax = p975.5, ymin = p0.025)) +
    #    geom_line(aes(x = jaar, y = p975.5), linetype = "longdash") +
    #    geom_line(color = "lightblue") +
    #    #geom_point(data = mdata, aes_string(x = "jaar", y = respons)) +
    #    geom_hline(aes(yintercept = 0), linetype = "dotted") +
    #    labs(x = "Jaar", y = "trend")
    #  gplot
    # 
    # #conclusie negative binomiaal (bij 30 wel onderdispersed), gestandardiseerd met een gewijzigde non-informatieve prior
    # 
    # result_stat_i_meetpunt <-  I2$summary.random$meetpunt %>% 
    #   mutate(simulatienr = i)
    
    # result_stat_i <- result_stat_i %>% 
    #   mutate(og_berekend = mean - 1.96*sd,
    #          bg_berekend = mean + 1.96*sd)
    
    #gefitte waarden (deze zijn wel teruggetransformeteerd)    
    varname_mean <- paste0("p", percentile, "_mean", if (standardised == TRUE) ("_std"), "_fitted")
    varname_sd <- paste0("p", percentile, "_sd", if (standardised == TRUE) ("_std"), "_fitted")
    varname_p025 <- paste0("p", percentile, "_p02.5", if (standardised == TRUE) ("_std"), "_fitted")
    varname_p975 <- paste0("p", percentile, "_p97.5", if (standardised == TRUE) ("_std"), "_fitted")
    result_fitted_i <-  I2$summary.fitted.values %>% 
      rename(!!varname_mean := mean,
             !!varname_sd := sd,
             !!varname_p025 := '0.025quant',
             !!varname_p975 := '0.975quant')

    mdata <- bind_cols(mdata, result_fitted_i) %>% 
      slice(-(1:nrow(jaren))) #de regels met lege responsen hieruit verwijderen    
    if (standardised == TRUE) {
      varname_mean_backtransformed <- paste0(varname_mean, "_untr")
      varname_p025_backtransformed <- paste0(varname_p025, "_untr")
      varname_p975_backtransformed <- paste0(varname_p975, "_untr")
      result_fitted_i <- result_fitted_i %>% 
        mutate( !!varname_mean_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_mean),m,s),
                !!varname_p025_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_p025),m,s),
                !!varname_p975_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_p975),m,s)    
        )
    }
    if (teller == 1) {
      result_stat <- result_stat_i
      result_fitted <- mdata
      
    } else {
      result_stat <- bind_rows(result_stat, 
                               result_stat_i)
      result_fitted <- bind_rows(result_fitted, mdata)    
    }
    
    if (teller == length(reeks)) {  
      result_stat <- result_stat %>% 
        rename( p02.5 = '0.025quant',
                p50 = '0.5quant',
                p97.5 = '0.975quant')
      
        if (standardised == TRUE) {
          result_stat <- result_stat %>% 
            mutate(mean_untr = unscale(mean, m, s),
                   og_berekend_untr = unscale(og_berekend, m, s),
                   bg_berekend_untr = unscale(bg_berekend, m, s),
                   p02.5_untr = unscale(p02.5, m, s),
                   p97.5_untr = unscale(p97.5, m, s),
                   se_berekend_untr = ((p97.5_untr  - mean_untr )/1.96 - 
                                         (p02.5_untr  - mean_untr )/1.96)/2,
            )
        }
      resultlijst <- list( result_stat, 
                           result_fitted)
      names(resultlijst) <- c(resultname_stat, resultname_fitted)
      list2env(resultlijst, envir = .GlobalEnv)
      
      if (varname_mean %in% colnames(dagen_droog)) {
        dagen_droog <- dagen_droog %>% 
          dplyr::select(-!!varname_mean, -!!varname_sd, -!!varname_p025, -!!varname_p975) 
      }
      
      dagen_droog <- dagen_droog %>% 
         inner_join(result_fitted %>% 
                      dplyr::select(contains("fitted"), 1:3), 
                    by = c("meetpunt","simulatienr", "jaar")) 
    }
  }
  return(dagen_droog)
}

```

```{r abs-indic-model-function-final}
indic_abs_function <- function(modeldata, suffix= "", respons, percentile, indicatorname, standardised, cache, tijdsvenster) {
  #De instelling van de prior heeft een doorslaggevend effect op de vorm van de trendlijn. 
  #Geven we het model de vrijheid om een trendlijn te bepalen dan voegen we weinig apriori-kennis toe aan het model
  #Voor de random-walk van de tweede orde doen we dat via de prior voor de precisie. Deze bevat twee elementen: de standaarddeviatie en een alfa. Het eerste element geeft aan in welke mate we denken/willen dat de rw2 mag fluctueren en en de alfa de zekerheid die we daarover hebben. Wil je een quasi rechte lijn, dan moeten beide parameters klein ingesteld worden. Laat je ze vrij, dan kan de trend een grillig patroon gaan vertonen.
  
  #voor de trendlijn zijn we vrij streng om een min of meer rechte, zacht glooiende, lijn te krijgen
  prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.025, 0.001)))
  
  #ivm de variatie op de meetpunten brengen we niet veel voorkennis in het model, om deze zoveel mogelijk door het model te laten bepalen
  prec.prior.mp <- list(theta = list(prior = "pc.prec", param = c(0.025, 0.95)))# list(theta = list(prec = list(param = c(0.001, 0.001)))) 
  #nog vrijer is om met de default-priors te werken en dus niets op te geven - model_free

  
  # prec.prior.mp.rw <- list(theta = list(prior = "pc.prec", param = c(0.5, 0.01)))
  
  #eenmalig aanmaken van moving-window venster
  d_jaar <- dagen_droog[dagen_droog$simulatienr == 1,"jaar"]
  lc_iyear <- rbind(
    moving_trend(
      n_year = max(d_jaar, na.rm = TRUE) - min(d_jaar, na.rm = TRUE), first_year = min(d_jaar, na.rm = TRUE),
      trend_year = 2
    ),
    moving_trend(
      n_year = max(d_jaar, na.rm = TRUE) - min(d_jaar, na.rm = TRUE), first_year = min(d_jaar, na.rm = TRUE),
      trend_year = 6
    ),
    moving_trend(
      n_year = max(d_jaar, na.rm = TRUE) - min(d_jaar, na.rm = TRUE), first_year = min(d_jaar, na.rm = TRUE),
      trend_year = 10
    ),
    moving_trend(
      n_year = max(d_jaar, na.rm = TRUE) - min(d_jaar, na.rm = TRUE), first_year = min(d_jaar, na.rm = TRUE),
      trend_year = 30
    )
  )
  lc <- inla.make.lincombs(jaar = lc_iyear) %>%
    setNames(rownames(lc_iyear))
  
  #rollend gemiddelde berekenen
  for (ma in tijdsvenster) {
    
    
    respons.ma <- paste0(respons,".", ma )
    model <- as.formula(paste(respons.ma, "~", "f(jaar, model =", "'rw2', scale.model = TRUE,
                            hyper = prec.prior) + f(meetpunt, model = 'iid', hyper = prec.prior.mp)", sep = " ")) 
  
    model_free <- as.formula(paste(respons.ma, "~", "f(jaar, model =", "'rw2', scale.model = TRUE,
                            hyper = prec.prior) + f(meetpunt, model = 'iid')", sep = " "))   
    # model_rwmp <- as.formula(paste(respons, "~", "f(jaar, model =", "'rw2', scale.model = TRUE,
    #                         hyper = prec.prior) + f(meetpunt, model =", "'rw1', scale.model = TRUE,
    #                         hyper = prec.prior.mp.rw)", sep = " ")) 
    
    suffix <- ifelse(suffix == "", "", paste0("_", suffix))
    resultname_stat <- paste0("indic_abs_p", percentile,".", ma, suffix, "_jaar_stat", if (standardised == TRUE) ("_std"))
    resultname_stat_meetpunt <- paste0("indic_abs_p", percentile,".", ma, suffix, "_meetpunt_stat", if (standardised == TRUE) ("_std"))
    resultname_mov.average <- paste0("indic_abs_p", percentile,".", ma, suffix, "_mov.average_stat", if (standardised == TRUE) ("_std"))
    resultname_fitted <- paste0("indic_abs_p", percentile,".", ma, suffix, "_fitted", if (standardised == TRUE) ("_std"))
    if (percentile == "01") {
      reeks <- c(1:20) #1 model wou maar niet convergeren
    } else {
      reeks <- c(1:20)    
    }  
    teller <- 0
    for (i in reeks) {
      #i = 16
      
      #samenstellen van een tweeledig dataframe. De eerste 34 rijen (#jaren) zijn leeg en dienen om de gemiddelde waarden en de bijhorende fouten te berekenen. Het tweede deel dient om het model mee te bouwen    
      mdata <- modeldata[modeldata$simulatienr == i,]
      jaren <- mdata %>% distinct(jaar) %>% mutate(simulatienr = i)
      meetpunten <- mdata %>% distinct(meetpunt) %>% mutate(simulatienr = i)
      mdata <- bind_rows(jaren, meetpunten, mdata)    
  
      print(paste("tijdsvenster = ", ma, " simulatienr = ", i))    
      teller <- teller + 1
      I2 <- inla(model_free, 
                        control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
                        lincomb = lc,
                        family = modelkeuze %>% filter(percentiel == percentile) %>% 
                                dplyr::pull(model), 
                        data = mdata
      )
      # I2_ma <- inla(model_free, 
      #                   control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
      #                   lincomb = lc,
      #                   family = modelkeuze %>% filter(percentiel == percentile) %>% 
      #                           dplyr::pull(model), 
      #                   data = mdata
      # )
      
      
      # I2_rw <- inla(model_rwmp, 
      #                  control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
      #                  family = modelkeuze %>% filter(percentiel == percentile) %>% 
      #                           dplyr::pull(model), 
      #                  data = mdata
      # )
  
      #linear_predictor : deze is niet teruggetransformeteerd. We zijn hier alleen geïnteresseerd in de rijen met lege responsen: hier krijg je dan per jaar een gemiddelde predictie én de se.
      result_stat_i <- I2$summary.linear.predictor %>% 
        slice(1:nrow(jaren)) %>% 
        bind_cols(jaren) %>% 
        mutate(intercept = I2$summary.fixed$mean) %>% 
        dplyr::select(-mode, -kld)    
  
      result_stat_meetpunt_i <- I2$summary.linear.predictor %>% 
        slice((nrow(jaren) + 1):((nrow(jaren) + nrow(meetpunten)))) %>% 
        bind_cols(meetpunten) %>% 
        mutate(intercept = I2$summary.fixed$mean) %>% 
        dplyr::select(-mode, -kld)    
      
      result_mov.average_i <- I2$summary.lincomb.derived %>%
        rownames_to_column(var = "parameter") %>%
        extract(
          .data$parameter, c("jaar", "duration"), "trend_(.*)_(.*)",
          convert = TRUE
          ) %>%
      # transmute(
      #   .data$jaar, duur = .data$duration, median = .data$`0.5quant`,
      #   lcl = .data$`0.025quant`, ucl = .data$`0.975quant`
      # )    
        mutate(intercept = I2$summary.fixed$mean,
               simulatienr = i) %>% 
        dplyr::select(-mode, -kld, -ID)   
    
      # result_stat_rw_i <- I2_rw$summary.linear.predictor %>% 
      #   slice(1:nrow(jaren)) %>% 
      #   bind_cols(jaren) %>% 
      #   mutate(intercept = I2_rw$summary.fixed$mean) %>% 
      #   dplyr::select(-mode, -kld)    
      # 
      # result_stat_rw_meetpunt_i <- I2_rw$summary.linear.predictor %>% 
      #   slice((nrow(jaren) + 1):((nrow(jaren) + nrow(meetpunten)))) %>% 
      #   bind_cols(meetpunten) %>% 
      #   mutate(intercept = I2_rw$summary.fixed$mean) %>% 
      #   dplyr::select(-mode, -kld)           
          #gefitte waarden (deze zijn wel teruggetransformeteerd)    
      varname_mean <- paste0("p", percentile, ".", ma, "_mean", if (standardised == TRUE) ("_std"), "_fitted")
      varname_sd <- paste0("p", percentile, ".", ma, "_sd", if (standardised == TRUE) ("_std"), "_fitted")
      varname_p025 <- paste0("p", percentile, ".", ma, "_p02.5", if (standardised == TRUE) ("_std"), "_fitted")
      varname_p975 <- paste0("p", percentile, ".", ma, "_p97.5", if (standardised == TRUE) ("_std"), "_fitted")
      result_fitted_i <-  I2$summary.fitted.values %>% 
        rename(!!varname_mean := mean,
               !!varname_sd := sd,
               !!varname_p025 := '0.025quant',
               !!varname_p975 := '0.975quant')
  
      mdata <- bind_cols(mdata, result_fitted_i) %>% 
        slice(-(1:(nrow(jaren) + nrow(meetpunten)))) #de regels met lege responsen hieruit verwijderen    
      
      if (standardised == TRUE) {
        varname_mean_backtransformed <- paste0(varname_mean, "_untr")
        varname_p025_backtransformed <- paste0(varname_p025, "_untr")
        varname_p975_backtransformed <- paste0(varname_p975, "_untr")
        result_fitted_i <- result_fitted_i %>% 
          mutate( !!varname_mean_backtransformed := unscale(result_fitted_i %>% 
                                                              dplyr::pull(!!varname_mean),m,s),
                  !!varname_p025_backtransformed := unscale(result_fitted_i %>% 
                                                              dplyr::pull(!!varname_p025),m,s),
                  !!varname_p975_backtransformed := unscale(result_fitted_i %>% 
                                                              dplyr::pull(!!varname_p975),m,s)    
          )
      }
      if (teller == 1) {
        result_stat <- result_stat_i
        result_stat_meetpunt <- result_stat_meetpunt_i
        result_mov.average <- result_mov.average_i
        result_fitted <- mdata
        
      } else {
        result_stat <- bind_rows(result_stat, 
                                 result_stat_i)
        result_stat_meetpunt <- bind_rows(result_stat_meetpunt, 
                                 result_stat_meetpunt_i)
        result_mov.average <- bind_rows(result_mov.average,
                                        result_mov.average_i)
        result_fitted <- bind_rows(result_fitted, mdata)    
      }
      
      if (teller == length(reeks)) {  
        result_stat <- result_stat %>% 
          rename( p02.5 = '0.025quant',
                  p50 = '0.5quant',
                  p97.5 = '0.975quant')
        result_stat_meetpunt <- result_stat_meetpunt %>% 
          rename( p02.5 = '0.025quant',
                  p50 = '0.5quant',
                  p97.5 = '0.975quant')   
        result_mov.average <- result_mov.average %>% 
          rename( p02.5 = '0.025quant',
                  p50 = '0.5quant',
                  p97.5 = '0.975quant')    
        if (standardised == TRUE) {
            result_stat <- result_stat %>% 
              mutate(mean_untr = unscale(mean, m, s),
                     og_berekend_untr = unscale(og_berekend, m, s),
                     bg_berekend_untr = unscale(bg_berekend, m, s),
                     p02.5_untr = unscale(p02.5, m, s),
                     p97.5_untr = unscale(p97.5, m, s),
                     se_berekend_untr = ((p97.5_untr  - mean_untr )/1.96 - 
                                           (p02.5_untr  - mean_untr )/1.96)/2,
              )
            result_stat_meetpunt <- result_stat_meetpunt %>% 
              mutate(mean_untr = unscale(mean, m, s),
                     og_berekend_untr = unscale(og_berekend, m, s),
                     bg_berekend_untr = unscale(bg_berekend, m, s),
                     p02.5_untr = unscale(p02.5, m, s),
                     p97.5_untr = unscale(p97.5, m, s),
                     se_berekend_untr = ((p97.5_untr  - mean_untr )/1.96 - 
                                           (p02.5_untr  - mean_untr )/1.96)/2,
              )
                    }
        resultlijst <- list( result_stat, 
                             result_stat_meetpunt,
                             result_mov.average,
                             result_fitted)
        names(resultlijst) <- c(resultname_stat, resultname_stat_meetpunt, resultname_mov.average, resultname_fitted)
        list2env(resultlijst, envir = .GlobalEnv)
        
        if (varname_mean %in% colnames(dagen_droog)) {
          dagen_droog <- dagen_droog %>% 
            dplyr::select(-!!varname_mean, -!!varname_sd, -!!varname_p025, -!!varname_p975) 
        }
        
        dagen_droog <- dagen_droog %>% 
           inner_join(result_fitted %>% 
                        dplyr::select(contains("fitted"), 1:3), 
                      by = c("meetpunt","simulatienr", "jaar")) 
      }
    }
    #opslaan van de intermediaire tabellen en resultaat als rds-bestand
    tabellen_lijst_rds <- list( 
            naamdoeltabel = file.path(cache, paste0(c(resultname_stat, resultname_stat_meetpunt, resultname_mov.average, resultname_fitted), ".rds")),
            naambrontabel =  c(resultname_stat, resultname_stat_meetpunt, resultname_mov.average, resultname_fitted)) 
    sapply(1:length(tabellen_lijst_rds$naambrontabel), function(i) {
            filename <- tabellen_lijst_rds$naamdoeltabel[i]
            saveRDS(get(tabellen_lijst_rds$naambrontabel[i]), filename)
        }) 
    saveRDS(c(resultname_stat, resultname_stat_meetpunt, resultname_mov.average, resultname_fitted), 
            file.path(cache, paste0("model_namen_intermediair.",ma,".rds" )))  
  }
  saveRDS(dagen_droog, file.path(cache, "modelresultaat.rds" ))

  
  return(dagen_droog)
}

```

```{r abs-indic-model-backup data}
dagen_droog_bu <- dagen_droog 
```

```{r abs-indic-model, include=FALSE, eval = !file.exists(file.path("cache", "modelresultaat.rds" ))}
#bij een eventuele herberekening moet de velden met de rekenresultaten eerst verwijderd worden
dagen_droog <- dagen_droog %>% 
  dplyr::select(-contains("fitted") )



modelkeuze <- data.frame(percentiel = c("01", "05", "10", "30" ), model = c("zeroinflatednbinomial2", "zeroinflatednbinomial0", "zeroinflatednbinomial0", "nbinomial"))
modelkeuze$model <- as.character(modelkeuze$model)

#keuze van parameters
percentile <- "05"
indicatorname <- paste0("dag_onder_p",percentile)
indicatorname_inv <- paste0("dag_boven_p",percentile)
standardised <- FALSE
respons <- paste0(indicatorname, if (standardised == TRUE) ("_std"))

dagen_droog <- indic_abs_function(modeldata = modeldata, respons = respons, percentile = percentile, indicatorname = indicatorname, standardised = standardised, cache = "cache", tijdsvenster = tijdsvenster)

```

```{r abs-indic-model-uit-cache, include=FALSE}
dagen_droog_update <- readRDS(file.path("cache", "modelresultaat.rds" ))
for (ma in tijdsvenster) {
  namen_intermediaire_tabellen <- readRDS(file.path("cache", paste0("model_namen_intermediair.",ma,".rds" ) ))
  for (i in 1:length(namen_intermediaire_tabellen)) {
    assign(namen_intermediaire_tabellen[i], readRDS(paste0(file.path("cache", namen_intermediaire_tabellen[i]), ".rds" )))
  }
}
```

```{r trend-data-vc, include=FALSE}

#bewaren resultaat
write_vc(dagen_droog_update, file.path("data", "result", "dagen-droog"), sorting = c("jaar", "meetpunt", "simulatienr"), strict = FALSE)

```

```{r trend-rubin, message=FALSE, warning=FALSE, include=FALSE}

#berekenen van indicator
indic_abs_gem <- dagen_droog_update %>% 
  group_by(jaar) %>% 
  summarise_at(vars(starts_with("dag_onder_p05.")), list(gem = mean, med = median)) %>% 
  ungroup


# rekening houden met multiple imputaties

teller <- 1
for (ma in tijdsvenster) {
  d <- get(paste0("indic_abs_p05.",ma,"_jaar_stat")) %>% 
    group_by(jaar) %>% 
    summarise(gem_jaar_t = mean(mean),
              var_sim = sum(sd^2) / 20 + (1 + 1/20) * sum((mean - gem_jaar_t)^2)/(20 - 1),
              og_jaar_t = gem_jaar_t - 1.96 * sqrt(var_sim),
              bg_jaar_t = gem_jaar_t + 1.96 * sqrt(var_sim),
              gem_jaar = exp(gem_jaar_t),
              og_jaar = exp(og_jaar_t),
              bg_jaar = exp(bg_jaar_t)
    ) %>% 
    ungroup() %>% 
    mutate(tijdsvenster = ma) %>% 
    inner_join(droogte_ind_j_ma, by = c("jaar", "tijdsvenster"))
  
  if (teller == 1) {
    droogte_trend_05 <- d
  } else {
    droogte_trend_05 <- bind_rows(droogte_trend_05, d)
  }

  d <- get(paste0("indic_abs_p05.",ma,"_mov.average_stat")) %>%
    group_by(jaar, duration) %>%
    summarise(gem_jaar_t = mean(mean) + mean(intercept),
              var_sim = sum(sd^2) / 20 + (1 + 1/20) * sum((mean - mean(mean))^2)/(20 - 1),
              og_jaar_t = gem_jaar_t - 1.96 * sqrt(var_sim),
              bg_jaar_t = gem_jaar_t + 1.96 * sqrt(var_sim),
              gem_jaar = exp(gem_jaar_t),
              og_jaar = exp(og_jaar_t),
              bg_jaar = exp(bg_jaar_t)
    ) %>%
    ungroup() %>%
    bind_rows(droogte_ind_j_ma %>% filter (tijdsvenster == ma)) %>%
    mutate(tijdsvenster = ma)

  if (teller == 1) {
    droogte_trend.mov_05 <- d
  } else {
    droogte_trend.mov_05 <- bind_rows(droogte_trend.mov_05, d)
  }
  
  teller <- teller + 1
}
```

Figuur \@ref(fig:trend-fitting-fig) geeft het resultaat van de modelbouw. 
De figuur toont de zowel de werkelijke waarden (punten) als de door het model geschatte waarden per meetpunt met hun betrouwbaarheidsinterval. 

```{r trend-fitting-fig-save, message=FALSE, warning=FALSE, include=FALSE}
#tabel met de indicatorwaarden (rollend gemiddelden) en trend berekening (model) omvormen naar een lange versie
dagen_droog_lang_breed <- dagen_droog_update %>% 
  pivot_longer(cols = starts_with("p05."), names_to = "statistiek", values_to = "waarde") %>% 
  mutate(tijdsvenster = as.integer(substr(statistiek, 4 + 1,  str_locate(string = statistiek, pattern = "_") - 1)),
          statistiek = paste0(substr(statistiek,1,3), str_sub(statistiek, start = str_locate(string = statistiek, pattern = "_")[,1], -1)
                                   )
         ) %>% 
  pivot_wider(names_from = statistiek, values_from = waarde) %>% 
  pivot_longer(cols = starts_with("dag_onder_p05."), names_to = "rollendgem", values_to = "waarde") %>% 
  mutate(tijdsvenster2 = as.integer(str_sub(rollendgem, 14 + 1,-1)),
        rollendgem = "dag_onder_p05.ma"
        ) %>% 
  filter(tijdsvenster == tijdsvenster2) %>% 
  pivot_wider(names_from = rollendgem, values_from = waarde) %>% 
  dplyr::select(-tijdsvenster2)

fig <- plotfitting(indic_basis = dagen_droog_lang_breed, respons = "dag_onder_p05.ma", gemid = "p05_mean_fitted", og = p05_p02.5_fitted, bg = p05_p97.5_fitted)
png(paste0(file.path("data","result", "figures","dagen-droog-p05"),"-tijdreeks",".png"), width = 1500, height = 1500, res = 150)
fig
dev.off()

```

(ref:trend-fitting-fig) Het aantal droogte-dagen (zwarte bollen) in vergelijking tot de met het tijdreeksmodel geschatte gemiddelde waarden per meetpunt (rode lijn) en hun betrouwbaarheidsinterval (grijze zone)

```{r trend-fitting-fig, fig.cap="(ref:trend-fitting-fig)",  message=FALSE, warning=FALSE}
fig
```

Figuur \@ref(fig:trend-fig) geeft de droogte-indicator (tijdsvenster = 0 jaar) met zijn betrouwbaarheidsinterval in het rood en de trend met zijn betrouwbaarheidsinterval in het donkerblauw. 
Tevens geeft de figuur ook de trend voor de verschillende rollende gemiddelden. 
Het valt op dat het tijdreeksmodel de feitelijke indicatorwaarden niet volgt. 
Het was een bewuste keuze bij het ontwerp om een uitgevlakte curve te berekenen (cfr. keuze voor random walk van de tweede orde i.p.v. de eerste orde). 
Bij de rollende gemiddelden worden de pieken afgevlakt en dan is goed te zien dat naarmate door het vergroten van het tijdsvenster deze uitvlakken het tijdreeksmodel de resulterende golfbeweging steeds beter kan bijhouden.
Het valt bij de grotere tijdsvensters ook op te merken dat de gemiddelde waarde duidelijk hoger is dan de referentie van 18 dagen. 
Dit is volledig toe te schrijven aan de combinatie van de berekeningswijze van de kritische drempelwaarde, nl. een gemiddelde berekenen van afzonderlijke jaargemiddelden i.p.v. een gemiddelde voor het volledige tijdsvenster (cfr. \@ref(h3-2:drempelwaarde) en het feit dat range van mogelijke afwijkingen voor droge jaren veel groter is dan de range bij natte jaren.
Daaruit kan men concluderend dat de referentie van 18 dagen enkel op jaarbasis mag gebruikt worden om te bepalen of het tijdens dat jaar al dan niet droog was.

Op de vraag welk tijdsvenster nu het meest toepasselijk is kan niet eenduidig worden geantwoord. 
Dat hangt namelijk af van de responstijd van het (eco)systeem dat men beschouwt. 
Voor snelle systemen zal eerder een klein tijdsvenster het meest relevant zijn om de impact van droogte te duiden. 
Voor trage systemen kunnen vooral de lange termijn-schommelingen een rol spelen.

(ref:trend-fig) De droogte-indicator (tijdsvenster = 0 jaar) en de hiervan afgeleide rollende gemiddelden met hun betrouwbaarheidsinterval (rood) en de modelmatig berekende trends met hun betrouwbaarheidsintervallen (resp. donkerblauw en grijs).
 
```{r trend-fig-save, fig.cap="trend", message=FALSE, warning=FALSE, include=FALSE}
#plot van de trend
gplot <- plottrend(droogte_trend_05,"droogte_ind_j", 18)
png(paste0(file.path("data","result", "figures","dagen-droog-p05"),"-trend-allevensters",".png"), width = 1500, height = 1500, res = 150)
gplot
dev.off()
```

```{r trend-fig, fig.cap="(ref:trend-fig)",  message=FALSE, warning=FALSE}
gplot
```

```{r trend-voor-1-venster-fig-save, fig.cap="trend één venster", message=FALSE, warning=FALSE, include=FALSE}
#plot van de trend
gplot <- plottrend.1venster(droogte_trend_05,"droogte_ind_j", intercept = 18, tijdsvenster = 0)
png(paste0(file.path("data","result", "figures","dagen-droog-p05"),"-trend-origineel",".png"), width = 1500, height = 1500, res = 150)
gplot
dev.off()
gplot <- plottrend.1venster(droogte_trend_05,"droogte_ind_j", 18, tijdsvenster = 8)
png(paste0(file.path("data","result", "figures","dagen-droog-p05"),"-trend-8jaar",".png"), width = 1500, height = 1500, res = 150)
gplot
dev.off()
```


```{r trend-vc, include=FALSE}
#bewaren resultaten
write_vc(droogte_trend_05, file.path("data", "result", "droogte-trend-05"), sorting = c("jaar", "tijdsvenster"), strict = FALSE)

write_vc(dagen_droog_lang_breed, file.path("data", "result", "droogte-fitting-05"), sorting = c("jaar", "simulatienr", "tijdsvenster"), strict = FALSE)
```


```{r trend-csv-voor-nara, include=FALSE}
#bewaren data voor figuur in nara
write_csv(droogte_trend_05 %>% 
            dplyr::select(jaar, gem_jaar, og_jaar, bg_jaar, droogte_ind_j, lcl, ucl, tijdsvenster) %>% 
            rename(`aantal dagen onder kritisch minimum` = droogte_ind_j,
                   og_jaar_trend =  og_jaar,
                   bg_jaar_trend = bg_jaar,
                   og_jaar_indicator = lcl,
                   bg_jaar_indicator = ucl), file.path("data", "result", "figuur-nara.csv"))
```

