---
title: "tube_selection"
author: "Jan Wouters"
date: "16 juli 2019"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	eval = FALSE,
	dpi = 300,
	include = FALSE
)
options(stringsAsFactors = FALSE)
# library(plyr)
library(raster)
library(tidyverse)
library(stringr)
library(knitr)
library(sf)
library(git2rdata)
library(lubridate)
opts_chunk$set(
  echo = FALSE,
  dpi = 300
)
# install watina-package branch develop_fv
# remotes::install_github("inbo/watina",
#                         ref = "develop_fv")
library(watina)
?watina

# install n2khab-package
# remotes::install_github("inbo/n2khab",
#                         build_opts = c("--no-resave-data", "--no-manual"))
library(n2khab)

# source("../../n2khab/R/read_habitatdata.R")
# source("../../n2khab/R/read_types.R")
# inladen van n2khab-functions (workaround for loading error package)
# path_to_n2khabR <- "../../n2khab/R/"
# functions_in_n2khabR <- list.files(path = path_to_n2khabR, pattern = "R")
# path_function_in_n2khabR <- paste0(path_to_n2khabR, functions_in_n2khabR)
# path_function_in_n2khabR <- setNames(path_function_in_n2khabR,
#          make.names(gsub("*.R$", "", functions_in_n2khabR)))
# list2env(
#   lapply(path_function_in_n2khabR,
#          source),
#   envir = .GlobalEnv)
# 
# source("./R/read_types_local.R")
# source("./R/read_textdata_local.R")

```
# Inlezen habitatkaart

```{r loading habitatmap, include=FALSE}
habpath <- "../data/local/n2khab-binaire-databronnen"
habfile <- "20_processed/habitatmap_stdized/habitatmap_stdized.gpkg"


habitatmap_stdized <- read_habitatmap_stdized(path = habpath)

habmap_polygons <- habitatmap_stdized$habitatmap_polygons

habmap_patches <- habitatmap_stdized$habitatmap_patches

types <- read_types(lang = "nl")

habmap_patches <- habmap_patches %>%
    mutate( polygon_id = as.factor(.data$polygon_id),
            patch_id = as.numeric(.data$patch_id),
            certain = .data$certain == 1,
            type = factor(.data$type,
                          levels = levels(types$type)
                          )
            )

```

# Inlezen meetnetdefinities Natura 2000 monitoring

Voor elk Natura 2000 meetnet is gedefinieerd welke habitattypen en rbbs daarin worden meegenomen.
Voor het meetnet voor de milieudruk 'verdroging via grondwater' (in de meetnetten natuurlijk milieu) betreft het grondwatergevoede habitattypen (ggHT).
Deze ggHT worden opgedeeld in 5 habitattypegroepen.
Voor het droogtemeetnet wordt deze 5-delige indeling gebruikt.  
HTgroep 5 bevat uitsluitend HT die zodanig breed gedefinieerd zijn dat ze op sommige locaties grondwatergevoed zijn, maar soms (meestal) niet. De vraag is of en indien ja hoe we dan die grondwatergevoede locaties kunnen selecteren.  
De HTgroepen lenen zich heel goed om een stratificatie uit te voeren op basis van de verwachte responssnelheid van een locatie op droogte. 
De permanent gevoede locaties (HT-groep 1) zullen naar verwachting trager reageren dan de tijdelijk of zwak gevoede locaties. 
Door een stratificatie over de HT-groepen toe te passen kan een zekere (nog af te spreken) balans worden verzekerd. 

```{r loading environmental schemes, echo=FALSE}
# read_schemes_local(path = "../../n2khab/inst/textdata")
gw_types <- read_scheme_types() %>%
    filter(scheme == "GW_05.1_terr") %>%
    arrange(typegroup) %>%
    mutate(groupnr = as.integer(str_sub(typegroup, -1))) %>% 
    select(type, groupnr)

```

# Verspreiding van de verdrogingsgevoelige typen in Vlaanderen volgens de habitatkaart.

```{r habitat selection, echo=FALSE}
habmap_patches_gw <- habmap_patches %>% 
  inner_join(gw_types, by = c("type" = "type"))
habmap_polygons_gw <- habmap_polygons %>% 
  inner_join(habmap_patches_gw %>% dplyr::select(-code_orig), by = "polygon_id")

```

```{r watina lokaal, eval=FALSE, include=FALSE}

loc_type <- "P"
loc_validity <- c("VLD", "ENT")
max_filterdepth <- 3
buffer <- 10
join_mask <- TRUE
locs <-
        tbl(watina, "vwDimMeetpunt") %>%
        filter(MeetpuntTypeCode %in% loc_type,
               MeetpuntStatusCode %in% loc_validity
               ) %>%
        left_join(tbl(watina, "vwDimGebied") %>%
                      dplyr::select(GebiedWID,
                             GebiedCode,
                             GebiedNaam),
                  by = "GebiedWID")
# 
#     if (!is.null(loc_vec)) {
#         locs <-
#             locs %>%
#             filter(.data$MeetpuntCode %in% loc_vec)
#     }
# 
#     if (!is.null(area_codes)) {
#         locs <-
#             locs %>%
#             filter(.data$GebiedCode %in% area_codes)
#     }
# 
#     if (!is.null(bbox)) {
#         bbox_xmin <- unname(bbox["xmin"])
#         bbox_xmax <- unname(bbox["xmax"])
#         bbox_ymin <- unname(bbox["ymin"])
#         bbox_ymax <- unname(bbox["ymax"])
#         locs <-
#             locs %>%
#             filter(.data$MeetpuntXCoordinaat >= bbox_xmin,
#                    .data$MeetpuntXCoordinaat <= bbox_xmax,
#                    .data$MeetpuntYCoordinaat >= bbox_ymin,
#                    .data$MeetpuntYCoordinaat <= bbox_ymax)
#     }
locs_lokaal <- locs %>% collect()
locs_vervolg_lokaal <-
        locs %>%
        left_join(tbl(watina, "vwDimPeilpunt") %>%
                      dplyr::select(MeetpuntWID,
                             PeilpuntStatusCode,
                             PeilbuisLengte,
                             ReferentieNiveauMaaiveld) %>%
                      filter(PeilpuntStatusCode %in% c("VLD",
                                                       "ENT",
                                                       "CLD")),
                  by = "MeetpuntWID")  %>%
        filter(MeetpuntTypeCode == "P" &
                   (PeilbuisLengte - ReferentieNiveauMaaiveld) <=
                     max_filterdepth |
                   MeetpuntTypeCode != "P"
               )   %>%
        dplyr::select(loc_wid = MeetpuntWID,
               loc_code = MeetpuntCode,
               area_code = GebiedCode,
               area_name = GebiedNaam,
               x = MeetpuntXCoordinaat,
               y = MeetpuntYCoordinaat,
               loc_validitycode = MeetpuntStatusCode,
               loc_validity = MeetpuntStatus,
               loc_typecode = MeetpuntTypeCode,
               loc_typename = MeetpuntType) %>% 
        distinct %>%
        arrange(area_code,
                loc_code) %>% 
      collect()
mask <- habmap_polygons_gw
    if (!is.null(mask)) {

        nr_dropped_locs <-
            locs_vervolg_lokaal %>%
            filter(is.na(x) | is.na(y)) %>%
            count %>%
            collect() %>%
            .$n 


        if (nr_dropped_locs > 0) {
            warning("Dropped ",
                    nr_dropped_locs,
                    " locations from which x or y coordinates were missing.")
        }

        locs <-
            locs_vervolg_lokaal %>%
            dplyr::select(-loc_wid) %>%
            filter(!is.na(x), !is.na(y)) %>%
            collect %>%
            as_points

        if (buffer != 0) {
            mask_expand <-
                mask %>%
                st_buffer(dist = buffer)
        } else {
            mask_expand <-
                mask
        }

        if (join_mask == FALSE) {

            locs <-
                locs %>%
                st_join(mask_expand,
                        left = FALSE) %>%
                st_drop_geometry

        } else {

            locs <-
                locs %>%
                .[mask_expand, ] %>% 
                st_drop_geometry

        }

    }

    # if (collect & is.null(mask)) {
    #     locs <-
    #         locs %>%
    #         select(-.data$loc_wid) %>%
    #         collect
    # }
```

# Ontwerp van een meetnet

Het basisidee van het meetnet is om zo veel mogelijk een ruimtelijk gebalanceerd en vooraf gekozen aantal meetpunten te selecteren. 
We kunnen geen zuiver ruimtelijk gebalanceerde set opbouwen. 
Een dergelijke set zou kunnen opgebouwd worden door een overlay te maken van de verspreiding van de HT-groepen met een fijn GTRS raster. 
In een GTRS-raster vormen een willekeurig gekozen subset van opeenvolgende genummerde punten steeds een ruimtelijk gebalanceerde set. 
Echter de kans dat zich op een dergelijk punt een bestaand grondwatermeetpunt bevindt is weinig realistisch.

Om toch een zo goed mogelijk ruimtelijk gebalanceerde spreiding te garanderen wordt Vlaanderen opgedeeld in een raster van cellen van een bepaalde gelijke grootte. 
De keuze van celgrootte (en dus het aantal) cellen is bepaald door de ingeschatte grootte van het meetnet (en de minimale afstand tussen twee meetpunten). 
Hoe kleiner de celgrootte, hoe beter de ruimtelijke balans is, omdat men minder vrij is om een locatie te kiezen.  
We werken gestratificeerd volgens de 5-delige indeling van HT-groepen. 
Zo verzekeren we dat elke HT-groep voldoende gemonitord zal worden.

Niet elke cel is even belangrijk voor de monitoring van een HT-groep, want de oppervlakte van ggHT verschilt van cel tot cel. 
Het heeft geen zin om in een raster een meetpunt te voorzien voor een HT-groep indien die groep daar niet in aanwezig is.  

De raster-cellen zullen dus niet obv GRTS geselecteerd worden, maar in verhouding tot de relatieve oppervlakte van een HT-groep dat het bevat. 
Hiertoe kan als maat de gemiddelde oppervlakte van een HT-groep per gewenst meetpunt gebruikt worden. 

```{r meetnet ontwerp}
# gewenst_totaal_aantal_meetpunten
tot_n_tub <- 100
# aantal stratificatielagen
aantal_strat <- 5

#importeren van GRTS-lagen, voor het meetnet kiezen we level 8: cellen van 8192 m
datapath <- "../data/local/n2khab-binaire-databronnen"


#level 4 : resolutie = 512m, level 5 :  1024m, level 6 = 2048, level 7= 4096, level 8 = 8192)
# test header 1 ----
# read_GRTSmh_diffres(datapath, level = 7)

# raster_meetnet <- read_GRTSmh_diffres(datapath, level = 9)
# raster_meetnet_64m <- read_GRTSmh_diffres(datapath, level = 1)
# 
# habmap_raster_group1 <- rasterize(habmap_polygons_gw %>% filter(groupnr == 1),raster_meetnet_64m,field = "groupnr", fun = sum, background = 0)
# habmap_raster_group2 <- rasterize(habmap_polygons_gw %>% filter(groupnr == 2),raster_meetnet_64m,field = "groupnr", fun = 'last' , background = 0)
# 
# test <- cellStats(habmap_raster_group2, max)
# plot(habmap_raster_group1)
# plot(habmap_raster_group2)
# plot(raster_meetnet)
# plot(habmap_polygons_gw %>% filter(groupnr == 2) %>% select(groupnr))
# 
# writeRaster(habmap_raster_group2, "./data/local/processed/habmap_raster_group2.grd", format = "raster")

raster_meetnet_poly <- read_GRTSmh_diffres(datapath, level = 8, polygon = TRUE)
# plot(raster_meetnet_poly)
#welke crs?
st_crs(habmap_polygons_gw)
st_crs(raster_meetnet_poly)


#check op unieke celwaarden
check <- raster_meetnet_poly %>% st_drop_geometry() %>% count(value) %>% filter(n > 1)
#van bepaalde cellen zijn er dus meerdere polygonen, dit zijn rasters die door de gewestgrens verdeeld werden (bijv. streek van Baarle-Nassau) 

raster_meetnet_poly <- raster_meetnet_poly %>% 
  rename(rasterid =  value)

# overlay maken van de habitatkaart (enkel van HT-groepen) en het GTRS-raster (level8)
habmap_gw_raster_overlay <- habmap_polygons_gw %>% 
  st_intersection(raster_meetnet_poly)

habmap_gw_raster_overlay <- habmap_gw_raster_overlay %>% 
    mutate(opp = as.integer(st_area(habmap_gw_raster_overlay))) 

#oppervlakte gw-groep per rastercel
raster_gw_opp <- habmap_gw_raster_overlay %>% 
  st_drop_geometry() %>% 
  group_by(rasterid,groupnr) %>% 
  summarise(opp_gw_cel = sum(opp*phab/100)) %>% 
  ungroup()
# view(raster_gw_opp)
raster_gw_opp

#totale opp van een gw-groep
gw_opp <- raster_gw_opp %>% 
  group_by(groupnr) %>% 
  summarise(opp_gw = sum(opp_gw_cel)) %>% 
  ungroup()

#benodigde oppervlakte van een gw-groep in een cel om hierin 1 meetpunt aan te duiden
#hier wordt voor de eenvoud nog een gelijke verdeling over de (5) strata genomen. Wijzigingen zijn mogelijk.

#invoeren van een correctiefactor om het wegvallen van meetpunten bij afronding naar een geheel getal te compenseren. Deze factor wordt routinematig berekend.

minaantal_tub_group <- tot_n_tub/aantal_strat
min_aantal_tub = data.frame("groupnr" = 1:5, minaantal = seq(20,20,length.out = 5))

for (group in seq(1,aantal_strat)) {
  # group <- 5
  minaantal_tub_group <- min_aantal_tub[min_aantal_tub$groupnr == group,"minaantal"]
  aantal_tub_group <- 0
  corrafronding <- 1
  while (aantal_tub_group < minaantal_tub_group) {
    gw_opp <- gw_opp %>% 
      mutate(minopp = opp_gw/minaantal_tub_group * corrafronding)
    gw_opp
    
    #berekening van het aantal meetpunten per cel

    aantal_meetpunten_cel_group <- raster_gw_opp %>% 
      inner_join(gw_opp, by = "groupnr") %>% 
      mutate(gew_aantal_meetptn = opp_gw_cel/minopp) %>% 
      arrange(desc(gew_aantal_meetptn))
    
    aantal_meetpunten_cel_group
    
    aantal_meetpunten_cel_group <- aantal_meetpunten_cel_group %>% 
      filter(gew_aantal_meetptn >= 0.5, groupnr == group) %>% 
      mutate(gew_aantal_meetptn_afgerond = round(gew_aantal_meetptn+0.01, digits = 0) )
    
    df <- aantal_meetpunten_cel_group %>% filter(groupnr == group)  %>% 
      summarise(aantal  = sum(gew_aantal_meetptn_afgerond)) %>% 
      ungroup() %>% 
      summarise(minaantal = min(aantal)) %>% 
      ungroup() 
    aantal_tub_group <- as.integer(df[1])
    corrafronding <- corrafronding - 0.01 
  }
  if (group == 1){
    aantal_meetpunten_cel <- aantal_meetpunten_cel_group
  } else {
    aantal_meetpunten_cel <- bind_rows(aantal_meetpunten_cel, aantal_meetpunten_cel_group)
  }
}
# df <- aantal_meetpunten_cel %>% group_by(groupnr)  %>% 
#    summarise(aantal  = sum(gew_aantal_meetptn_afgerond)) %>% 
#    ungroup()
# df

# Enkel bij groep 3 komt het opp-gerelateerd aantal meetptn overeen met het vereiste aantal. Voor de overige gw-groepen is het opp-gerelateerd aantal hoger. 
# Twv de ruimtelijke balancering wordt bij voorkeur voor de gw-groepen waar het minimum aantal wordt overschreden, dit aantal tot het minimum teruggebracht door de hokken te selecteren op basis van hun rangorde in het GTRS-raster. Men kan echter ook de koppeling met geschikte watina-meetptn afwachten. 
# We doen hier eerst de aanbevolen GRTS-strategie
# if (df[df$groupnr == 1,"aantal"] > minaantal_tub_group) {}
# 
# sel_raster <- raster_meetnet_poly %>% 
#   st_drop_geometry()  %>% 
#   inner_join(raster_gw_opp, by = "rasterid") %>% 
#   inner_join(aantal_meetpunten_cel_group, by =  c("rasterid", "groupnr")) %>% 
#   inner_join(min_aantal_tub, by = "groupnr") %>% 
#   group_by(groupnr) %>% 
#   distinct(rasterid, minaantal) %>% 
#   top_n(minaantal, rasterid)
# 
# sel_raster_meetnet <- raster_meetnet_poly %>% 
#   inner_join(sel_raster, by = "rasterid")
# 
# plot(sel_raster_meetnet)


#cellen selecteren met een gewenst meetpunt, een cel kan voor meerdere HT-groepen geselecteerd zijn
sel_raster_meetnet <- raster_meetnet_poly %>%
  inner_join(raster_gw_opp, by = "rasterid") %>%
  inner_join(aantal_meetpunten_cel %>% 
               select(rasterid, groupnr, gew_aantal_meetptn_afgerond), 
             by =  c("rasterid", "groupnr")) %>% 
  rename(gew_aantal_meetptn = gew_aantal_meetptn_afgerond)


# voorbeeld van rasters van HT-groep 1 (permanent nat)
plot(sel_raster_meetnet %>% filter(groupnr == 1))


```

# Opgave van de grondwater-meetpunten (Watina-databank) die gelegen zijn in een verdrogingsgevoelig type.  

Hierbij werd met een zoekstraal van 10 meter rond een meetpunt gewerkt.
```{r loading and selecting tubes watina, echo=FALSE}
watina <- connect_watina()

?watina
?selectlocs_xg3
?get_locs
# debugonce(get_locs)
tubes_hab <- get_locs(watina, mask = habmap_gw_raster_overlay, join_mask = TRUE, buffer = 10, loc_type = "P", loc_validity = c("VLD", "ENT"), collect = TRUE)

#save tubes_hab as a git2rdata-object
tubes_hab <- tubes_hab %>% 
  arrange(loc_code, polygon_id, rasterid, patch_id, type)
write_vc(tubes_hab, file.path("..","data","tubes_hab"), sorting = c("loc_code", "polygon_id", "rasterid", "patch_id", "type" ), strict =  FALSE)

str(tubes_hab)

# een peilbuis kan meerdere keren voorkomen, wanneer de pb in een bwk-complex ligt. We kunnen ze groeperen als de verschillende eenheden tot eenzelfde gw-groep behoren.
# Alleen de gw-groep met een opp-aandeel van minstens 50% wordt weerhouden. Dit om te vermijden dat indien een rastercel gekozen werd voor een bep. gw-groep, een pb geselecteerd wordt waarvan de kans klein is dat ze die gw-groep representeert.

tubes_hab_groep <- tubes_hab %>%
  group_by(loc_code, polygon_id, rasterid, groupnr) %>%
  summarise(phab_gw = sum(phab),
            aantal =  n()) %>%
  ungroup() %>% 
  filter(phab_gw >= 50)

tubes_hab_aggr <- tubes_hab %>% 
  semi_join(tubes_hab_groep, by = c("loc_code", "polygon_id", "rasterid", "groupnr" ))

DBI::dbDisconnect(watina)

```
# Opzoeken van Watina-meetpunten in de geselecteerde cellen ('sel-cellen')

```{r tubes (watina) in selected cells}
tubes_in_raster <- tubes_hab %>% 
  select(-10:-15, -opp) %>%  
  inner_join(sel_raster_meetnet %>% 
               select(rasterid, groupnr) %>% 
               st_drop_geometry(), by = c("rasterid", "groupnr")) %>% 
  distinct()

tubes_in_raster
```
# Zijn er sel-cellen zonder watina-meetpunt?

```{r tubeless selcells, warning== FALSE}
sel_no_tube <- sel_raster_meetnet %>% 
  anti_join(tubes_in_raster, group_by = c("rasterid", "groupnr")) %>% 
  distinct(rasterid, groupnr) %>% 
  arrange(rasterid)

plot(sel_no_tube %>% select(groupnr) %>% filter(groupnr == 2))

sel_no_tube_table <- sel_no_tube %>% 
  st_drop_geometry() %>% 
  distinct(rasterid, groupnr) %>% 
  arrange(rasterid)

sel_no_tube_table %>%
  group_by(groupnr ) %>% 
  summarise('aantal cellen zonder peilbuis' = n())


```
Ja, een 'r as.integer(sel_no_tube_table %>% count %>% magrittr::extract(1,1))'-tal

# Selectie van meetpunten met een goede tijdreeks binnen de geselecteerde cellen
Als selectiecriteria gelden:
startjaar : 2001 of later
eindjaar : 2016. De extreem droge zomers van 2017 en 2018 worden niet meegenomen in de berekening. Het is nu nog onduidelijk of de actuele vegetatie geen nadelige effecten van deze twee zomers heeft gekend (door naijling).
minimale lengte van de tijdreeks : 5 jaar
maximale duur van een onderbreking van de tijdreeks :  2 jaar

```{r selection tubes with good time-series in selected cells}
watina <- connect_watina()

tubes_xg3 <- tubes_in_raster %>% 
    get_xg3(watina, startyear = year(now()) - 18, endyear = 2016, vert_crs = "local", truncated =  TRUE, collect = TRUE)
tubes_xg3 <- tubes_xg3 %>% 
  arrange(loc_code, hydroyear)
write_vc(tubes_xg3, file.path("..","data","tubes_xg3"), sorting = c("loc_code", "hydroyear"), strict =  FALSE)

tubes_lg3_avail <- tubes_xg3 %>% 
    eval_xg3_avail( xg3_type = "L")
# debugonce(eval_xg3_series)
tubes_lg3_eval <-   tubes_xg3 %>%
  eval_xg3_series(xg3_type = c("L"),
                  max_gap = 2,
                  min_dur = 5)

# sessioninfo::session_info()

DBI::dbDisconnect(watina)
```
# Koppeling van lg3-meetpunten aan de geselecteerde rastercellen

```{r join tubes with a xg3 on the raster_survey}

sel_raster_lg3 <- sel_raster_meetnet %>% 
  inner_join(tubes_in_raster, by = c("rasterid", "groupnr")) %>% 
  left_join(tubes_lg3_eval, by = "loc_code") %>% 
  group_by(rasterid, groupnr, gew_aantal_meetptn) %>% 
  summarise(n_tubes = n(),
            n_tubes_lgl = sum(!is.na(series) & str_ends(series, "1")),
            max_nryears = max(ser_nryears, na.rm =  TRUE)) %>% 
  mutate(max_nryears = ifelse(max_nryears > 0, max_nryears, NA)) %>% 
  ungroup %>% 
  select(-max_nryears) %>% 
  select(-geom, geom)

sel_raster_lg3 %>% st_drop_geometry()

```

Hieruit blijkt dat er behoorlijk veel rastercellen zijn met een meetpunt, maar waarvoor de bestaande metingen niet toelaten een LGL te berekenen. Onderstaande tabel geeft hiervan een overzicht.
```{r raster cells with one or more tubes but without lgl}
sel_raster_no_lgl <- sel_raster_lg3 %>% 
  filter(n_tubes_lgl == 0) %>% 
  st_drop_geometry() %>% 
  summarise('# cellen met pb zonder xg3' = n())
sel_raster_no_lgl
sel_raster_lg3 %>% count(n_tubes_lgl == 0) %>% st_drop_geometry()


```
```{r count points with tubes but without lgl }
sel_points_no_lgl <- sel_raster_lg3 %>% 
  filter(n_tubes_lgl < gew_aantal_meetptn)

sel_points_no_lgl %>% 
  st_drop_geometry() %>% 
  summarise('# meetptn met pb zonder xg3' = sum(gew_aantal_meetptn) - sum(n_tubes_lgl))

```

# Opzoeken van peilbuizen met lg3 voor rastercellen zonder of met een onvoldoende aantal peilbuizen met een LGL
```{r tubes with lg3 but no lgl}
tubes_to_inspect <- tubes_lg3_avail %>% 
  inner_join(tubes_in_raster %>% 
               select(loc_code, rasterid, groupnr) , by = "loc_code") %>% 
  inner_join(sel_points_no_lgl %>% 
               st_drop_geometry(), by = c("rasterid", "groupnr")) %>%
  filter(nryears >= 0) %>% 
  arrange(rasterid, groupnr, desc(nryears), desc(firstyear)) %>% 
  select(rasterid, groupnr, gew_aantal_meetptn, loc_code, everything(), -xg3_variable)
head(tubes_to_inspect, 10)
write_csv(tubes_to_inspect, file.path("..", "data","local", "tubes_to_inspect.csv"))

sel_zonder_lg3 <- sel_points_no_lgl %>% 
  anti_join(tubes_to_inspect, by = c("rasterid", "groupnr"))

cat("Aantal meetpunten zonder lg3")
sel_zonder_lg3 %>% 
  st_drop_geometry() %>% 
  summarise(n_points_without_lg3 = sum(gew_aantal_meetptn))
# tubes_in_raster %>% filter(rasterid == 46)
```

# Verfijnen selectie bij overaanbod van meetpunten (deel 1)
Hiervoor hanteren we drie bijkomende criteria.
* Meetpunten met een recente tijdreeks primeren boven meetpunten met een oudere tijdreeks. De meetpunten worden hierbij gerangschikt volgens aflopend jaartal van de laatst beschikbare kwalitatief goede tijdreeks. Meetpunten worden als evenwaardig beschouwd als het verschil niet groter dan 5 jaar is. 
* Meetpunten met een lange tijdreeks krijgen ook een hogere prioriteit. Meetpunten waarvan de lengte van de tijdreeks niet meer dan 5 jaar van elkaar verschillen, worden als evenwaardig beschouwd.
* Een meetpunt met een lange tijdreeks, maar niet recent, krijgt een hogere prioriteit dan een meetpunt met een recentere maar kortere tijdreeks.
* Indien er dan nog het aantal beschikbare meetpunten groter is dan het aantal gewenste, wordt een keuze gemaakt dmv het 32m GRTS-raster. Het/de meetpunt(en) met de laagste rasternr(s) wordt/worden dan gekozen, in overeenstemming met het gewenst aantal meetpunten.
```{r setting quality criteria}
toelaatbare_spreiding_jaren <- 5
toelaatbaar_verschil_lengte_tijdreeks <- 5

# #clusteren meetpunten binnen een rastercel obv jaar laatste tijdreeks
# sel_qual_lastyear <- sel_raster_meetnet %>% 
#               select(rasterid, groupnr, gew_aantal_meetptn) %>% 
#               st_drop_geometry() %>% 
#               anti_join(sel_points_no_lgl, by = c("rasterid", "groupnr")) %>% 
#   inner_join(tubes_in_raster, by =  c("rasterid", "groupnr")) %>% 
#   distinct(rasterid, groupnr, gew_aantal_meetptn, loc_code) %>% 
#   inner_join(tubes_lg3_eval, by = "loc_code") %>% 
#   group_by(rasterid, groupnr, gew_aantal_meetptn) %>% 
#   count(ser_lastyear) %>% 
#   arrange(rasterid, groupnr, gew_aantal_meetptn, desc(ser_lastyear)) %>% 
#   mutate(minrank = min_rank(desc(ser_lastyear))) %>% 
#   ungroup()


#functie om de meetpunten te clusteren waarvan hun laatste jaar van kwalitatief goede tijdreeks niet meer dan zeker aantal jaar verschilt 

# sel_qual_test <- sel_qual %>%
#   mutate(ser_lastyear = case_when(
#     rasterid == 134 & groupnr == 4 & ser_lastyear ==2011 ~ 1990,
#     TRUE ~ ser_lastyear
#   ))

# sel_qual_lastyear <-  sel_qual_lastyear %>% 
#   group_by(rasterid, groupnr) %>% 
#   mutate(test =  cummax(ser_lastyear),
#          rankclus = floor((cummax(ser_lastyear) - ser_lastyear)/toelaatbare_spreiding_jaren)+1 ) %>% ungroup()


#clusteren meetpunten binnen een rastercel obv lengte tijdreeks en obv laatste meetjaar
sel_qual_basis <- sel_raster_meetnet %>% 
              select(rasterid, groupnr, gew_aantal_meetptn) %>% 
              st_drop_geometry() %>% 
              anti_join(sel_points_no_lgl, by = c("rasterid", "groupnr")) %>% 
  inner_join(tubes_in_raster, by =  c("rasterid", "groupnr")) %>% 
  distinct(rasterid, groupnr, gew_aantal_meetptn, loc_code) %>% 
  inner_join(tubes_lg3_eval, by = "loc_code") %>% 
  group_by(rasterid, groupnr, gew_aantal_meetptn) %>% 
  count(ser_lastyear, ser_nryears)  %>% 
  ungroup()

sel_qual_basis <-  sel_qual_basis %>% 
  group_by(rasterid, groupnr) %>% 
  arrange(rasterid, groupnr, gew_aantal_meetptn, desc(ser_lastyear))%>% 
  mutate(rankclus_lastyear = floor((cummax(ser_lastyear) - ser_lastyear)/toelaatbare_spreiding_jaren) + 1 ) %>% 
  arrange(rasterid, groupnr, gew_aantal_meetptn, desc(ser_nryears)) %>% 
  mutate(rankclus_nryears = floor((cummax(ser_nryears) - ser_nryears)/toelaatbaar_verschil_lengte_tijdreeks) + 1 ) %>% 
  ungroup()

sel_qual <- sel_qual_basis %>% 
  group_by(rasterid, groupnr, gew_aantal_meetptn, rankclus_lastyear, rankclus_nryears) %>% 
  mutate(rankclus_temp = as.integer(paste0(rankclus_lastyear,rankclus_nryears))) %>% 
  arrange(rasterid, groupnr,rankclus_temp) %>% 
  ungroup() %>% 
  group_by(rasterid, groupnr) %>% 
  mutate(rankclus = min_rank(rankclus_temp)) %>% 
  group_by(rasterid, groupnr, gew_aantal_meetptn, rankclus, rankclus_lastyear, rankclus_nryears) %>% 
  summarise(beschikbaar_aantal_cluster = sum(n)) %>% 
  ungroup 

# functie om de rang te bepalen die nodig is om tot het gewenst aantal meetpunten te komen

max_rank <-  function(x) {
  # x <- sel_qual_test %>% filter (rasterid == 134, groupnr == 4)
  clusters <- unique(x$rankclus) 
  gewenst_aantal <- x[1,"gew_aantal_meetptn"] %>%
    as.integer()
  beschikbaar_aantal <- 0
  einde <- 0


  for (i in clusters) {
    # i <- 1
    rank <- as.integer(i)
    beschikbaar_aantal_rank <-  x[1,"beschikbaar_aantal_cluster"] %>%
    as.integer()
    if (gewenst_aantal <= (beschikbaar_aantal_rank + beschikbaar_aantal) & einde == 0) {
      maxrank <- rank
      einde <- 1
    } else {
      beschikbaar_aantal <- beschikbaar_aantal_rank + beschikbaar_aantal
    }  
  }
return(maxrank)
}

# check <- sel_qual_lastyear_vb %>% 
#   filter(rasterid == 134, groupnr == 4)

#test
# sel_qual_lastyear <- sel_qual_lastyear %>%
#   mutate(gew_aantal_meetptn = case_when(
#     rasterid == 198 & groupnr == 4 ~ 6,
#     TRUE ~ gew_aantal_meetptn
#   ))

sel_qual_test <- sel_qual %>%
  mutate(gew_aantal_meetptn = case_when(
    rasterid == 134 & groupnr == 4  ~ 5,
    TRUE ~ gew_aantal_meetptn
  ))

sel_qual_maxrank <- plyr::ddply(sel_qual, ~rasterid+groupnr, max_rank) %>%
  rename(maxrank = V1)

sel_qual <- sel_qual %>%
  inner_join(sel_qual_maxrank, by = c("rasterid", "groupnr"))

# rastercellen met een juist voldoende aantal evenwaardige meetpunten dat gewenst is voor het meetnet
sel_sufficient_lgl <- sel_qual %>% 
  filter(rankclus <= maxrank ) %>% 
  group_by(rasterid, groupnr, gew_aantal_meetptn) %>% 
  summarise(beschikbaar_aantal = sum(beschikbaar_aantal_cluster)) %>% 
  ungroup %>% 
  inner_join(sel_qual_test ) %>% 
  filter(beschikbaar_aantal == gew_aantal_meetptn) %>% 
  select(-beschikbaar_aantal, -maxrank)

# de bijhorende geselecteerde Watina-meetpunten zijn dan
tubes_selected_1 <- tubes_in_raster %>% 
  inner_join(tubes_lg3_eval %>% 
               select(loc_code, ser_lastyear, ser_nryears), by = "loc_code") %>% 
  inner_join(sel_sufficient_lgl %>%
               inner_join(sel_qual,  by =  c("rasterid","groupnr","rankclus" )) %>% 
               inner_join(sel_qual_basis, by =  c("rasterid","groupnr","rankclus_lastyear", "rankclus_nryears" )), by = c("rasterid", "groupnr", "ser_lastyear", "ser_nryears"))

# rastercellen met een overschot aan evenwaardige meetpunten dat gewenst is voor het meetnet
sel_qual_lastyear <- sel_qual_lastyear_vb %>% 
  left_join(sel_qual_lastyear_maxrank, by = c("rasterid", "groupnr")) %>% 
  filter(minrank <= maxrank) %>% 
  group_by(rasterid, groupnr, gew_aantal_meetptn, maxrank) %>% 
  summarise(beschikbaar_aantal = sum(n)) %>% 
  ungroup %>% 
  inner_join(sel_qual_lastyear_vb %>%
              select(rasterid, groupnr, minrank, ser_lastyear) ) %>% 
  filter(beschikbaar_aantal > gew_aantal_meetptn, minrank <= maxrank) %>% 
  select(-ends_with("rank"))

#bijhorende Watina-meetpunten ervan opzoeken
tubes_excess <- tubes_in_raster %>% 
  distinct(loc_code, x, y, rasterid, groupnr) %>% 
  inner_join(tubes_lg3_eval, by =  "loc_code") %>% 
  inner_join(sel_qual_lastyear, by =  c("rasterid", "groupnr", "ser_lastyear"))

tubes_excess <- tubes_excess %>% 
  rownames_to_column("unieknr") %>% 
  mutate(unieknr = as.integer(unieknr))
# sel_qual_lastyear_vb %>% 
#   count(rasterid, groupnr )


```

```{r eval=FALSE, include=FALSE}
write_vc(habmap_raster)
raster_meetnet_polyg <- st_as_sf(rasterToPolygons(raster_meetnet))
raster_meetnet_polyg <- st_transform(raster_meetnet_polyg, crs = 31370)
test <- intersect(raster_meetnet_polyg, habmap_polygons_gw)



st_crs(raster_meetnet_polyg)
ggplot(raster_meetnet_polyg ) +
  geom_sf() +
  scale_color_viridis_c(trans = "sqrt", alpha = .9) + 
  coord_sf(datum = sf::st_crs(31370))



st_crs(habmap_polygons_gw)
ggplot(habmap_polygons_gw %>% slice(100:300)) +
  geom_sf(aes(colour = groupnr)) +
  scale_color_viridis_c(trans = "sqrt", alpha = .9) + 
  coord_sf(datum = sf::st_crs(31370))

head(habmap_polygons_gw)

# library(stars)
# ggplot() +
#   geom_stars(data = test)
plot(raster_meetnet)
zoom(raster_meetnet, ext = drawExtent())
fromDisk(raster_meetnet)
hasValues(raster_meetnet)

# cells <- c(1:40000)
# r <- rasterFromCells(test, cells, values = FALSE)
# plot(r)

#random selectie van een aantal gebalanceerde rastercellen
set.seed(12345)
  #gewenst_totaal_aantal_meetpunten
tot_n_tub <- 100



aantal_strat <- 5

for (i in seq(1:aantal_strat)) {
  random_integer <- as.integer(runif(1, min  = 1, max = maxValue(raster_meetnet) - tot_n_tub))
  m <- c(0, random_integer - 1, 0, random_integer,  random_integer + (tot_n_tub/aantal_strat) - 1, 1, random_integer + (tot_n_tub/aantal_strat) - 1, maxValue(raster_meetnet), 0)
  rclmat <- matrix(m, ncol = 3, byrow = TRUE)
  rc <- reclassify(raster_meetnet, rclmat)  
  assign(paste0("raster_group", i), rc)
}
plot(raster_group3)
# reclassify the values into three groups 
# all values >= 0 and <= 0.25 become 1, etc.
m <- c(0, 60000, 0,  60000, 70000, 1)
rclmat <- matrix(m, ncol = 3, byrow=TRUE)
rc <- reclassify(test, rclmat)
plot(rc)
```

# Verfijnen selectie bij overaanbod van meetpunten (deel 2)
```{r using GRTS for refining tubeselection part2}
tubes_excess_sf <- as_points(tubes_excess)
tubes_excess_gw_raster_overlay <- tubes_excess_sf %>% 
  distinct(loc_code, x, y) %>% 
  st_intersection(raster_meetnet_poly)

sel_excess <- tubes_excess_gw_raster_overlay %>%
  st_drop_geometry() %>% 
  distinct(rasterid) %>% 
  arrange(rasterid)

grts_level1 <- read_GRTSmh(datapath, brick = TRUE) %>% 
  subset(1)
grts_level9 <- read_GRTSmh(datapath, brick = TRUE) %>% 
  subset(9)
clip9 <- grts_level9[grts_level9 == 113, drop =  FALSE]
# plot(clip9)
clip1 <- grts_level1[clip9, drop =  FALSE]
# plot(clip1)

tubes_excess_raster1 <- rasterize(tubes_excess %>% select(x, y) %>% as.matrix(), clip1, mask = TRUE)
# plot(tubes_excess_raster1)
check <- tubes_excess_raster1 %>% 
  getValues() %>% 
  as.data.frame()
names(check) <- "celwaarde" 
check <- check %>% 
  filter(!is.na(celwaarde)) %>%  
  distinct() %>% 
  mutate (minrank = min_rank(celwaarde)) %>% 
  arrange(minrank)

check
clip1b <- clip1[clip1 == check[1,1], drop = FALSE]
tubes_excess_unieknr <- rasterize(tubes_excess %>% select(x, y) %>% as.matrix(), clip1b, field = tubes_excess %>% select(unieknr), mask = FALSE)
getValues(tubes_excess_unieknr)
uniek <- tubes_excess_unieknr %>% 
  getValues() %>% 
  as.data.frame()
names(uniek) <- "unieknr" 
uniek <- uniek %>% 
  filter(!is.na(unieknr)) %>%  
  distinct() %>% 
  mutate (minrank = min_rank(unieknr)) %>% 
  arrange(minrank)
uniek


check <- tubes_excess_gw_raster_overlay %>% 
  select(loc_code, rasterid, rasterid.1)
check <- read_GRTSmh(datapath, brick = TRUE)
test <- subset(check, 1)
test

test2
plot(test2)
elev <- spData::elev
clip <-  raster(xmn = 0.9, xmx = 1.8, ymn = -0.45, ymx = 0.45,
              res = 0.3, vals = rep(1, 9))
t <- elev[clip, drop =  FALSE]

clipj <- test2[test2==1014, drop =  FALSE]
tubes_excess_raster0 <- rasterize(tubes_excess %>% select(x, y) %>% as.matrix(), test, mask = TRUE)
tubes_excess_unieknr <- rasterize(tubes_excess %>% select(x, y) %>% as.matrix(), test, field = tubes_excess %>% select(unieknr), mask = FALSE)

plot(tubes_excess_unieknr)

test <- tubes_excess_raster0 %>% 
  interse

tubes_excess_pointsO <- rasterToPoints(tubes_excess_raster0)

e1 <- extent(-10, 10, -20, 20)
e2 <- extent(0, 20, -40, 5)
intersect(e1, e2)

t <- tubes_excess %>% select(rasterid) %>% as.character()
plot(test_clip)
r <- raster(ncols=36, nrows=18)
n <- 1000
set.seed(123)
x <- runif(n) * 360 - 180
y <- runif(n) * 180 - 90
xy <- cbind(x, y)
# get the (last) indices
r0 <- rasterize(xy, r)
plot(r2)
# presence/absensce (NA) (is there a point or not?)
r1 <- rasterize(xy, r, field=1)
# how many points?
r2 <- rasterize(xy, r, field = xy[,2])
vals <- runif(n)
# sum of the values associated with the points
r3 <- rasterize(xy, r, vals, fun=sum)




clipjb <- test2[rasterize(tubes_excess %>% select(x, y) %>% as.matrix(), test2, field = tubes_excess %>% pull(loc_code))]
test3 <- test[clipj, drop = FALSE]
test3b <- intersect(test, clipj)
compareRaster(test3, test3b)
 

test4 <- rasterToPolygons(test3)

tubes_excess_sf <- tubes_excess %>% 
  st_as_sf(coords = c("x", "y"), crs = 31370)

test5 <- tubes_excess_sf %>% 
  st_intersection(st_as_sf(test4, crs = 31370))

plot(test3)
plot(clipj)
# plot(test4)
test3 <- st_as_sf(test2) %>% 
  st_join(st_as_sf(test))

integer <- 1017
  m <- c(0, integer - 1, NA, integer,  integer , 1, integer +1 , 2000, NA)
  rclmat <- matrix(m, ncol = 3, byrow = TRUE)
  rc <- reclassify(test2, rclmat) 
  plot(rc)
  

```


## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
