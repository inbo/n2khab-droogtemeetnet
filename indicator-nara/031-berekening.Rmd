
# De berekening van de droogte-indicator, haar betrouwbaarheid en trend {#h4:berekening}

We verkiezen een absolute indicator als droogte-indicator.
Bij een dergelijke indicator wordt het aantal dagen per jaar dat het grondwaterpeil gelijk aan of onder een kritische drempelwaarde zakt opgeteld.
Deze kritische drempelwaarde is specifiek voor elk meetpunt.
Als kritische drempelwaarde wordt gekozen voor 
**het _jaargemiddelde_ van de 5%-percentiel van de grondwatermetingen _van een jaar_ voor het meetpunt voor de periode 1985 - 2014**, cfr. \@ref(h3-2:drempelwaarde), die periodiek, bijv. elke vijftien jaar, met meer recente data kan herijkt worden, cfr. \@ref(h2-2-1:referentietoestand).

## De voorbereiding {#h4-1:voorbereiding}

Tot op heden kon met het software-programma Menyanthes voor 58 meetpunten een tijdreeksmodel gemaakt worden, waarbij 

- neerslag en potentiële evapotranspiratie voor minstens 66% van de waargenomen variatie kon verklaren en
- er geen significante trend in de tijdreeks kon gedetecteerd worden.

Met deze modellen werden 20 tijdreeksen van dagelijkse grondwaterpeilen gesimuleerd voor de periode 1985 - 2018.
Deze data werden in een centrale databank opgeslagen om daarna te worden ingelezen in R. 
De hierop volgende analysen gebeurden volledig in R.

```{r functies}
#grafiek voor het bekijken van de modelfitting. Het plot de gemeten data (in werkelijkheid omvatten ze zowel geïmputeerde data als veldmetingen) en de gefitte waarden incl credible interval. 

#hulpfunctie voor het maken van minor ticks in de grafieken
insert_minor <- function(major_labs, n_minor) {
  labs <- c( sapply( major_labs, function(x) c(x, rep("", 4) ) ) )
  labs[1:(length(labs) - n_minor)]}

#plot van de modelfitting
plotfitting <- function(indic_basis, respons, gemid, og, bg) {
  og <- enquo(og)
  bg <- enquo(bg)
  # PI_data <- indic_basis %>% group_by(jaar) %>% 
  #   summarise(ymax_data = max(!! bg, na.rm = TRUE), ymin_data = min(!! og, na.rm = TRUE))
  
  PI_data <- indic_basis %>% group_by(jaar, tijdsvenster) %>% 
    summarise(ymax_data = max(!! bg, na.rm = TRUE), ymin_data = min(!! og, na.rm = TRUE)) %>% 
    ungroup() %>% 
    inner_join(dagen_droog_lang_breed)
  
  p <- ggplot(data = PI_data, aes_string(y = respons, x = "jaar"))
  p <- p + xlab("Jaar") + ylab("Aantal dagen onder kritsche drempelwaarde")
  # p <- p + theme(text = element_text(size = 15))
  p <- p + geom_point(shape = 16, size = 2, col = "black")
  p <- p + geom_line(aes_string(x = "jaar", y = gemid), size = 1, color = "red")
  p <- p + geom_ribbon(aes(x = jaar, ymax = ymax_data, ymin = ymin_data),
                       fill = grey(0.5),
                       alpha = 0.4)
  p <- p + scale_x_continuous(breaks = 1985:2020, 
                              labels = insert_minor(seq(1985, 2020, by = 5), 4))
  # p <- p + theme(strip.text = element_text(size = 15))
  p <- p + facet_wrap(vars('tijdsvenster (jaren) ' = tijdsvenster), labeller = label_both)
  return(p)
}

#plot van de rollende gemiddelden
plotma.basis <- function(indic_finaal, indicator, intercept) {
  p <- ggplot(data = indic_finaal ) + 
    geom_line(data = indic_finaal %>% filter(jaar >= 1985 + tijdsvenster), aes(x = jaar, y = lcl), linetype = "longdash") +
    geom_line(data = indic_finaal %>% filter(jaar <= 1985 + tijdsvenster), aes(x = jaar, y = lcl), linetype = "longdash", alpha = 0.20) +
    geom_ribbon(data = indic_finaal %>% filter(jaar >= 1985 + tijdsvenster), aes(x = jaar, ymax = ucl, ymin = lcl),
                fill = "lightpink",
                alpha = 0.4) +
    geom_ribbon(data = indic_finaal %>% filter(jaar <= 1985 + tijdsvenster), aes(x = jaar, ymax = ucl, ymin = lcl),
                fill = "lightpink",
                alpha = 0.15) +
    geom_line(data = indic_finaal %>% filter(jaar >= 1985 + tijdsvenster), aes(x = jaar, y = ucl), linetype = "longdash") +
    geom_line(data = indic_finaal %>% filter(jaar <= 1985 + tijdsvenster), aes(x = jaar, y = ucl), linetype = "longdash", alpha = 0.20) +
    geom_line(data = indic_finaal %>% filter(jaar >= 1985 + tijdsvenster), aes_string(x = "jaar", y = indicator), color = "red" ) +
    geom_line(data = indic_finaal %>% filter(jaar <= 1985 + tijdsvenster), aes_string(x = "jaar", y = indicator), color = "red", alpha = 0.15 ) +    
    geom_hline(aes(yintercept = intercept), linetype = "dotted")
  return(p)
}

plotma.basis_1venster <- function(indic_finaal, indicator, intercept, tijdsvenster) {
  tv <- tijdsvenster
  indic_finaal_1 <- indic_finaal %>% filter(tijdsvenster == tv)
  p <- ggplot(data = indic_finaal_1 ) + 
    geom_line(data = indic_finaal_1 %>% filter(jaar >= 1985 + tv), aes(x = jaar, y = lcl), linetype = "longdash") +
    geom_line(data = indic_finaal_1 %>% filter(jaar <= 1985 + tv), aes(x = jaar, y = lcl), linetype = "longdash", alpha = 0.20) +
    geom_ribbon(data = indic_finaal_1 %>% filter(jaar >= 1985 + tv), aes(x = jaar, ymax = ucl, ymin = lcl),
                fill = "lightpink",
                alpha = 0.4) +
    geom_ribbon(data = indic_finaal_1 %>% filter(jaar <= 1985 + tv), aes(x = jaar, ymax = ucl, ymin = lcl),
                fill = "lightpink",
                alpha = 0.15) +
    geom_line(data = indic_finaal_1 %>% filter(jaar >= 1985 + tv), aes(x = jaar, y = ucl), linetype = "longdash") +
    geom_line(data = indic_finaal_1 %>% filter(jaar <= 1985 + tv), aes(x = jaar, y = ucl), linetype = "longdash", alpha = 0.20) +
    geom_line(data = indic_finaal_1 %>% filter(jaar >= 1985 + tv), aes_string(x = "jaar", y = indicator), color = "red" ) +
    geom_line(data = indic_finaal_1 %>% filter(jaar <= 1985 + tv), aes_string(x = "jaar", y = indicator), color = "red", alpha = 0.15 ) +    
    geom_hline(aes(yintercept = intercept), linetype = "dotted")
  return(p)
  }

plotma <-  function(indic_finaal, indicator, intercept) {
    p <- plotma.basis(indic_finaal, indicator, intercept)
    p <- p + 
      scale_x_continuous(breaks = 1985:2020, labels = insert_minor(seq(1985, 2020, by = 5), 4)) +
      labs(x = "Jaar", y = "indicator (rollend gemiddelde)") +
      facet_wrap(vars('tijdsvenster (jaren) ' = tijdsvenster), labeller = label_both)
    return(p)
}

#plot van de trend (zowel modelschatting als berekende)
plottrend <- function(indic_finaal, indicator, intercept) {
    p <- plotma.basis(indic_finaal, indicator, intercept)
    p <- p +  
      geom_line(data = indic_finaal %>% filter(jaar >= 1985 + tijdsvenster), aes(x = jaar, y = og_jaar), linetype = "longdash") +
      geom_line(data = indic_finaal %>% filter(jaar <= 1985 + tijdsvenster), aes(x = jaar, y = og_jaar), linetype = "longdash", alpha = 0.20) +
      geom_ribbon(data = indic_finaal %>% filter(jaar >= 1985 + tijdsvenster), aes( x = jaar, ymax = bg_jaar, ymin = og_jaar),
                  fill = grey(0.5),
                  alpha = 0.4) +  
      geom_ribbon(data = indic_finaal %>% filter(jaar <= 1985 + tijdsvenster), aes( x = jaar, ymax = bg_jaar, ymin = og_jaar),
                  fill = grey(0.5),
                  alpha = 0.15) +  
      geom_line(data = indic_finaal %>% filter(jaar >= 1985 + tijdsvenster), aes(x = jaar, y = bg_jaar), linetype = "longdash") +
      geom_line(data = indic_finaal %>% filter(jaar <= 1985 + tijdsvenster), aes(x = jaar, y = bg_jaar), linetype = "longdash", alpha = 0.20) +
      geom_line(data = indic_finaal %>% filter(jaar >= 1985 + tijdsvenster), aes(x = jaar, y = gem_jaar), color = "dark blue") +
      geom_line(data = indic_finaal %>% filter(jaar <= 1985 + tijdsvenster), aes(x = jaar, y = gem_jaar), color = "dark blue", alpha = 0.20) +    
      geom_hline(aes(yintercept = intercept), linetype = "dotted") +
      scale_x_continuous(breaks = 1985:2020, labels = insert_minor(seq(1985, 2020, by = 5), 4)) +
      labs(x = "Jaar", y = "trend") +
      scale_y_continuous(sec.axis = dup_axis(name = "droogte-indicator")) +
      theme( axis.text.y.right = element_text(color = "red"), 
        axis.ticks.y.right = element_line(color = "red"), 
        axis.title.y.left =  element_text(color = "darkblue"),
        axis.title.y.right =  element_text(color = "red")
         ) + 
      facet_wrap(vars('tijdsvenster (jaren) ' = tijdsvenster), labeller = label_both)
    return(p)
}

#plot van de trend (zowel modelschatting als berekende) voor één bepaald tijdsvenster
plottrend.1venster <- function(indic_finaal, indicator, intercept, tijdsvenster) {
    p <- plotma.basis_1venster(indic_finaal, indicator, intercept, tijdsvenster)
    tv <- tijdsvenster
    indic_finaal_1 <- indic_finaal %>% filter(tijdsvenster == tv)    
    p <- p +  
      geom_line(data = indic_finaal_1 %>% filter(jaar >= 1985 + tv), aes(x = jaar, y = og_jaar), linetype = "longdash") +
      geom_line(data = indic_finaal_1 %>% filter(jaar <= 1985 + tv), aes(x = jaar, y = og_jaar), linetype = "longdash", alpha = 0.20) +
      geom_ribbon(data = indic_finaal_1 %>% filter(jaar >= 1985 + tv), aes( x = jaar, ymax = bg_jaar, ymin = og_jaar),
                  fill = grey(0.5),
                  alpha = 0.4) +  
      geom_ribbon(data = indic_finaal_1 %>% filter(jaar <= 1985 + tv), aes( x = jaar, ymax = bg_jaar, ymin = og_jaar),
                  fill = grey(0.5),
                  alpha = 0.15) +  
      geom_line(data = indic_finaal_1 %>% filter(jaar >= 1985 + tv), aes(x = jaar, y = bg_jaar), linetype = "longdash") +
      geom_line(data = indic_finaal_1 %>% filter(jaar <= 1985 + tv), aes(x = jaar, y = bg_jaar), linetype = "longdash", alpha = 0.20) +
      geom_line(data = indic_finaal_1 %>% filter(jaar >= 1985 + tv), aes(x = jaar, y = gem_jaar), color = "dark blue") +
      geom_line(data = indic_finaal_1 %>% filter(jaar <= 1985 + tv), aes(x = jaar, y = gem_jaar), color = "dark blue", alpha = 0.20) +    
      geom_hline(aes(yintercept = intercept), linetype = "dotted") +
      scale_x_continuous(breaks = 1985:2020, labels = insert_minor(seq(1985, 2020, by = 5), 4)) +
      labs(x = "Jaar", y = "trend") +
      scale_y_continuous(sec.axis = dup_axis(name = "droogte-indicator")) +
      theme( axis.text.y.right = element_text(color = "red"), 
        axis.ticks.y.right = element_line(color = "red"), 
        axis.title.y.left =  element_text(color = "darkblue"),
        axis.title.y.right =  element_text(color = "red")
         ) 
    return(p)
}
moving_trend <- function(n_year = 30, trend_year = 6, first_year = 1985) {
  trend_coef <- seq_len(trend_year) - (trend_year + 1) / 2
  trend_coef <- trend_coef / sum(trend_coef ^ 2)
  lc <- vapply(
    seq_len(n_year - trend_year + 1),
    function(i) {
      c(rep(0, i - 1), trend_coef, rep(0, n_year - trend_year - i + 1))
    },
    numeric(n_year)
  )
  colnames(lc) <- sprintf(
    "trend_%.1f_%i",
    seq_len(ncol(lc)) + first_year - 1 + (trend_year - 1) / 2, trend_year
  )
  t(lc)
}
```


<!-- ### Inlezen van ruwe gegevens van de SQL-server {#h4-1-1:ruwedata} -->

```{r inlezen-ruwe-data-sqlserver, eval=FALSE}
# De ruwe data staan op de SQL-server in de FlaVen-databank.
# Deze data is opgebouwd uit een reeks van 23 tabellen. Door deze op de SQL-server samen te voegen tot één bestand, zou het importeren falen.
# Het inlezen vergt een betrouwbare (langdurig werkzame) VPN-verbinding en vraagt ook veel tijd.
# Daarom werden de data na het inlezen omgezet in het VC-formaat (git2rdata-package) en lokaal/in github bewaard.
# Het inlezen van deze bestanden gaat 3x-sneller dan het inlezen van de SQL-server. 
# Het blijft tijdsbelastend, daarom wordt er na het inlezen een (tijdelijk) rds-bestand van gemaakt.

con <- dbConnect(odbc::odbc(), .connection_string = "Driver=SQL Server;Server=inbo-sql07-prd.inbo.be,1433;Database=D0136_00_Flaven;Trusted_Connection=Yes;")



ruwetabellen_lijst <- data.frame (a = "droogte_tijdreeks", b = "ruwedata", c = seq(from = 1, to = 23))

ruwetabellen_lijst <- ruwetabellen_lijst %>% mutate (naambrontabel = paste0(a,c), 
                                                     naamdoeltabel = sprintf(paste0(b,"%02d"), c)) 

ruwetabellen_lijst <- setNames(ruwetabellen_lijst %>% dplyr::pull(naambrontabel), make.names(ruwetabellen_lijst %>% dplyr::pull(naamdoeltabel)))


list2env(
  lapply(ruwetabellen_lijst, 
         dbReadTable, conn = con,
         guess_max = 300000), 
  envir = .GlobalEnv)

DBI::dbDisconnect(con)


```

```{r wegschrijven-brontabellen-naar-vc-formaat, eval=FALSE }
for (i in seq(from = 1, to = 19)){
  write_vc(get(sprintf("ruwedata%02d", i)), file.path("data", "local", sprintf("ruwedata%02d", i)), sorting = c("dag","meetpunt_import"), strict= FALSE)
}

```


```{r inlezen-vc-tabellen, include=FALSE, eval=!file.exists(file.path("cache", "basisdata.rds" ))}
# De data worden niet in één keer ingelezen.
# De brondata zitten in 23 bestanden.
# Elk van deze 23 bestanden is op zich al vrij omvangrijk.
# Ze samenvoegen tot één bestand, zou kunnen leiden tot importproblemen.
# De opdeling is ook wel praktisch als je met de data iets wil testen.

ruwetabellen_lijst <- data.frame(bron = "ruwedata", doel = "ruwedata", c = seq(from = 1, to = 23))

ruwetabellen_lijst <- ruwetabellen_lijst %>% mutate (naambrontabel = file.path("data", "local", paste0(bron,sprintf("%02d", c))), 
                                                     naamdoeltabel = sprintf(paste0(doel,"%02d"), c)) 
ruwetabellen_lijst_rds <- ruwetabellen_lijst %>% mutate(naamdoeltabel = file.path("cache", paste0(bron,sprintf("%02d", c), ".rds")), 
                                                     naambrontabel = sprintf(paste0(doel,"%02d"), c)) 

ruwetabellen_lijst <- setNames(ruwetabellen_lijst %>% dplyr::pull(naambrontabel), make.names(ruwetabellen_lijst %>% dplyr::pull(naamdoeltabel)))

list2env(
  lapply(ruwetabellen_lijst, 
         read_vc), 
  envir = .GlobalEnv)

sapply(1:nrow(ruwetabellen_lijst_rds), function(i) {
        filename <- ruwetabellen_lijst_rds$naamdoeltabel[i]
        saveRDS(get(ruwetabellen_lijst_rds$naambrontabel[i]), filename)
    })
```
```{r inlezen-vc-tabellen-uit-cache, include=FALSE}
ruwetabellen_lijst <- data.frame(bron = "ruwedata", doel = "ruwedata", c = seq(from = 1, to = 23))

ruwetabellen_lijst_rds <- ruwetabellen_lijst %>% mutate(naambrontabel = file.path("cache", paste0(bron,sprintf("%02d", c), ".rds")), 
                                                     naamdoeltabel = sprintf(paste0(doel,"%02d"), c)) 
ruwetabellen_lijst_rds <- setNames(ruwetabellen_lijst_rds %>% dplyr::pull(naambrontabel), make.names(ruwetabellen_lijst_rds %>% dplyr::pull(naamdoeltabel)))

list2env(lapply(X = ruwetabellen_lijst_rds, FUN = readRDS), 
  envir = .GlobalEnv)
```

```{r samenvoegen-bestanden, include=FALSE, eval=!file.exists(file.path("cache", "basisdata.rds" ))}
#ik verkies dit in een aparte chunk te doen, omdat het zo mogelijk is om testdata samen te stellen, bijv. ik heb voor het uittesten van de methoden gewerkt met een testbestand van de eerste 5 ruwe tabellen.
for (i in seq (from = 1, to = 23)){
  if (i == 1) {
    ruwedata <- get(sprintf("ruwedata%02d",i))
  } else {
    ruwedata <- bind_rows(ruwedata, get(sprintf("ruwedata%02d",i)))
  }
}

#data cleaning - algemeen
# 1) uitsluiten van niet gesimuleerde meetreeksen (veldmetingen zitten namelijk al in de simuleerde reeksen, zou dus tot dubbeltellingen leiden) 
# 2) factoriseren van meetpunt en weglaten van ongebruikte velden 

ruwedata <-  ruwedata %>% 
  filter(meetpunt_import != meetreeks, year(dag) >= 1985) %>%  # 
  mutate(meetpunt = factor(meetpunt)) %>% 
  dplyr::select(-meetpunt_import, -meetreeks, -is_veldmeting) #om de grootte van het databestand te reduceren

#data-cleaning - specifiek voor de eerste dataset
#1) jaar 2019 is onvolledig: slechts data tot half mei

ruwedata <- ruwedata %>% 
  filter( year(dag) < 2019)
# indic_abs_basis_gw <- indic_abs_basis_gw %>% 
#   filter( between(simulatienr, 1,20), jaar < 2019)

```

```{r samenvoegen-bestanden-test, include=FALSE, eval= FALSE}
#ik verkies dit in een aparte chunk te doen, omdat het zo mogelijk is om testdata samen te stellen, bijv. ik heb voor het uittesten van de methoden gewerkt met een testbestand van de eerste 5 ruwe tabellen.
for (i in seq (from = 1, to = 5)){
  if (i == 1) {
    ruwetest <- get(sprintf("ruwedata%02d",i))
  } else {
    ruwetest <- bind_rows(ruwetest, get(sprintf("ruwedata%02d",i)))
  }
}

#data cleaning
ruwetest <-  ruwetest %>% 
  filter(meetpunt_import != meetreeks, year(dag) >= 1985) %>%  #uitsluiten van niet gesimuleerde meetreeksen (veldmetingen zitten namelijk al in de simuleerde reeksen, zou dus tot dubbeltellingen leiden)  
  mutate(meetpunt = factor(meetpunt)) %>% 
  dplyr::select(-meetpunt_import, -meetreeks, -is_veldmeting) #om de grootte van het databestand te reduceren

ruwetest <- ruwetest %>% 
  filter( year(dag) < 2019)
```

```{r verwijderen-tsv-tabellen, eval = FALSE}
#verwijderen van de 23 deelbestanden (beter nog niet doen als je wil testen, het is handig om te testen met één van de bestanden, bijv. ruwedata01 (rel. groot) of ruwedata19 (rel klein)
rm(list = sprintf("ruwedata%02d", seq(from = 1, to = 23)))

```

```{r tubes-network, include=FALSE}
#laatste versie met de geselecteerde meetpunten ophalen. De ruwe data bevatten namelijk ook nog meetreeksen van punten van een eerdere versie.
gitroot <- rprojroot::find_root(rprojroot::is_git_root)
tubes_selected <- read_vc(file.path(".","data","result","meetnet","tubes_selected"), root = gitroot)

tubes_indicator <- tubes_selected %>% 
  filter(selectie == 1) %>% 
  dplyr::select(loc_code, groupnr)
```

```{r basisdata-final, include=FALSE, eval=!file.exists(file.path("cache", "basisdata.rds" ))}
#beperken van de ruwe data tot de laatste versie van de geselecteerde meetpunten
ruwedata <- ruwedata %>% 
  semi_join(tubes_indicator, by = c("meetpunt" = "loc_code"))

# #linken van de metingen aan een gw-groep, cfr. MNM
# tubes_in_raster <- read_vc(file.path(".","data","processed","meetnet","tubes_in_raster"), root = gitroot)
# tubes_gw <- tubes_in_raster %>% 
#   dplyr::select(loc_code, groupnr)
# ruwedata <- ruwedata %>% 
#   left_join(tubes_gw, by = c("meetpunt" = "loc_code")) #left_join om te testen

#wegschrijven in een RDS-bestand (= een soort controleerbare vorm van cache)
saveRDS(ruwedata,file.path("cache", "basisdata.rds" ))
```

```{r basisdata-final-uit-cache, include=FALSE}
ruwedata <- readRDS(file.path("cache", "basisdata.rds" ))
```


### Berekenen kritische drempelwaarden {#h4-1-1:drempelwaarde}
Een absolute indicator vergelijkt dagelijks het grondwaterpeil met een kritische drempelwaarde. 
De dagen dat het grondwaterpeil onder deze drempelwaarde valt, worden per jaar opgeteld (\@ref(h3-2:drempelwaarde) en \@ref(h3-3:indicator)).

```{r absolute-drempelwaarden, include=FALSE, eval = !file.exists(file.path("cache", "percentielen.rds" ))}
absperc <- ruwedata %>% 
  mutate(jaar = year(dag)) %>% 
  filter(dplyr::between(jaar,1985,2014)) %>% 
  group_by(meetpunt, jaar) %>% 
  summarise(p01 = quantile(meting_TAW, 1/100),
            p05 = quantile(meting_TAW, 5/100),
            p10 = quantile(meting_TAW, 10/100),
            p30 = quantile(meting_TAW, 30/100),
            p50 = quantile(meting_TAW, 50/100),
            p70 = quantile(meting_TAW, 70/100),
            p90 = quantile(meting_TAW, 90/100),
            p95 = quantile(meting_TAW, 95/100),
            p99 = quantile(meting_TAW, 99/100)
            ) %>% 
  group_by(meetpunt) %>% 
  summarise(p01 = mean(p01),
            p05 = mean(p05),
            p10 = mean(p10),
            p30 = mean(p30),
            p50 = mean(p50),
            p70 = mean(p70),
            p90 = mean(p90),
            p95 = mean(p95),
            p99 = mean(p99)
            ) %>%   
  ungroup()

#vrijmaken geheugenruimte, kan soms van pas komen
  gc()
```

```{r nakijken-tijdreeks, eval=FALSE}

#voor één simulatie
d <- ruwedata %>% 
  filter (meetpunt == "DORP002", year(dag) == 2000, simulatienr == 11) %>% 
  arrange(meting_TAW)
 p <- ggplot(dat = d, aes(x= row_number(meting_TAW), y= meting_TAW)) + geom_path() + 
   geom_vline(xintercept = 365*0.05) + 
   coord_cartesian(xlim = c(0, 365/10), ylim = c(min(d$meting_TAW), d %>% summarise(p05 = quantile(meting_TAW, 5/100)) %>% dplyr::pull(p05)))
 p

 dp05 <- d %>% summarise(p05 = quantile(meting_TAW, 5/100)) %>% dplyr::pull(p05) 

 #voor alle simulaties
 d.allesim <- ruwedata %>% 
  filter (meetpunt == "DORP002", year(dag) == 2000) %>% 
  arrange(meting_TAW)
 
dp05.all <- d.allesim %>% summarise(p05 = quantile(meting_TAW, 5/100)) %>% dplyr::pull(p05)

p.all <- ggplot(dat = d.allesim, aes(x= row_number(meting_TAW), y= meting_TAW)) + geom_path() + 
 geom_vline(xintercept = 365) + 
 coord_cartesian(xlim = c(365-50, 365+50), ylim = c(min(d.allesim$meting_TAW), max(dp05, dp05.all)))
p.all 
dp05.all <- d.allesim %>% summarise(p05 = quantile(meting_TAW, 5/100)) %>% dplyr::pull(p05)
dp05.all
 
d.allesim <- d.allesim %>% 
   mutate(onderp05 = ifelse(meting_TAW< dp05.all, 1,0))
d.allesim %>% count(onderp05)
d.allesim %>% group_by(simulatienr) %>% filter (onderp05==1) %>% count(onderp05) %>% ungroup() %>%  summarise(mean(n))

#eens het effect van 30 uitmiddelen berekenen voor één meetpunt
d <- ruwedata %>% 
  filter(dplyr::between(year(dag),1985,2014)) %>% 
  filter (meetpunt == "DORP002") 

d.check <- d %>% 
  inner_join(absperc) %>% 
  mutate(jaar = year(dag)) %>% 
  group_by(jaar) %>% 
  summarise(aantaldroog = sum(ifelse(meting_TAW < p05,1,0 ))) %>% 
  ungroup() %>% 
  summarise(gemdroog = mean(aantaldroog)/20)
#dus meer dan 18

#dit doen voor alle meetpunten
#eens het effect van 30 uitmiddelen berekenen voor één meetpunt

d.check <- ruwedata %>% 
  filter(dplyr::between(year(dag),1985,2014)) %>% 
  inner_join(absperc) %>% 
  mutate(jaar = year(dag)) %>% 
  group_by(jaar, meetpunt) %>% 
  summarise(aantaldroog = sum(ifelse(meting_TAW < p05,1,0 ))) %>% 
  ungroup() %>% 
  group_by(meetpunt) %>% 
  summarise(gemdroog = mean(aantaldroog)/20)
#voor alle meetpunten ligt dit gemiddelde boven 18. Dit betekent dat voor alle meetpunten het aantal overschrijdingen van de drempel tijdens droge jaren niet gecompenseerd wordt door het aantal onderschrijdingen in natte jaren. Dit kan te maken hebben dat het aantal droge dagen per jaar nooit lager dan nul kan zijn.
#gemiddeld is het 30 dagen

#berekenen we een drempelwaarde over het totaal aantal metingen over 30 jaar. Is dit dan ook nog zo ?
absperc.30 <- ruwedata %>% 
  mutate(jaar = year(dag)) %>% 
  filter(dplyr::between(jaar,1985,2014)) %>% 
  group_by(meetpunt) %>% 
  summarise(p01 = quantile(meting_TAW, 1/100),
            p05 = quantile(meting_TAW, 5/100),
            p10 = quantile(meting_TAW, 10/100),
            p30 = quantile(meting_TAW, 30/100),
            p50 = quantile(meting_TAW, 50/100),
            p70 = quantile(meting_TAW, 70/100),
            p90 = quantile(meting_TAW, 90/100),
            p95 = quantile(meting_TAW, 95/100),
            p99 = quantile(meting_TAW, 99/100)
            ) %>% 
  ungroup()

d.check.30 <- ruwedata %>% 
  filter(dplyr::between(year(dag),1985,2014)) %>% 
  inner_join(absperc.30) %>% 
  mutate(jaar = year(dag)) %>% 
  group_by(jaar, meetpunt) %>% 
  summarise(aantaldroog = sum(ifelse(meting_TAW < p05,1,0 ))) %>% 
  ungroup() %>% 
  group_by(meetpunt) %>% 
  summarise(gemdroog = mean(aantaldroog)/20)
#dit klopt dus: netjes 18.25 (behalve voor een meetpunt met slechts 29 meetjaren). Dit moest mathematisch wel kloppen.

#Dit betekent dat het verschil wel degelijk komt door eerst jaargemiddelden te berekenen en hiervan het gemiddelde te nemen.
#het feit dat het 30-jaargemiddelde duidelijk hoger is dan 18.25 (nl. ong. 30) ligt aan het feit dat een nat jaar nooit meer dan 18 dagen kan afwijken van een normaal jaar, terwijl een droog jaar tot wel 365 dagen kan afwijken => (28jaar * 18.25 + 1*365 + 1*0)/30 > 18.25

```

```{r schrikkeljaren, include=FALSE}

schrikkeljaar <- ruwedata %>% 
  mutate(jaar = year(dag)) %>%   
  filter(meetpunt == 
           ruwedata %>% 
           dplyr::select(meetpunt) %>% 
           head(1) %>% 
           dplyr::pull(meetpunt)
         ) %>% 
  filter(day(dag) == 29, month(dag) == 2) %>% 
  distinct(jaar) %>% 
  arrange(jaar) %>% 
  dplyr::pull(jaar)

```

```{r gwgroups, include=FALSE, eval = !file.exists(file.path("cache", "percentielen.rds" ))}
#herijking grondwatertype-groepen, want er blijkt nog nauwelijks een verband te bestaan tussen de amplitude van een pb en de gw-typegroep waartoe het wordt gerekend
absperc_gw <- absperc %>% 
  inner_join(tubes_indicator %>% 
               mutate(groep3 = ifelse(groupnr == 1, 2, groupnr)) %>% 
               dplyr::select(-groupnr), by = c("meetpunt" = "loc_code")) %>% 
  mutate(ampl = p99 - p01,
         groep3n = case_when(
           ampl < 0.25 ~2,
           ampl < 0.4 ~3,
           TRUE ~4),
         meetpunt = factor(meetpunt)
         )


#wegschrijven in een RDS-bestand
saveRDS(absperc_gw,file.path("cache", "percentielen.rds" ))

write_vc(absperc_gw, file.path("data", "result", "percentielen-1985-2014"), sorting = c("meetpunt"), strict = FALSE)

```

```{r gwgroups-uit-cache, include=FALSE}
absperc_gw <- readRDS(file.path("cache", "percentielen.rds" ))
```

```{r abs-indicator, eval = !file.exists(file.path("cache", "dagendroog.rds" ))}

dagen_droog <- ruwedata %>% #oude objectnaam: indic_abs_basis
  inner_join(absperc_gw, by = "meetpunt") %>% 
  mutate(jaar = year(dag),
         aantaldagen_jaar = if_else(jaar %in% schrikkeljaar, 366, 365 )
         ) %>% 
  mutate( 
          dag_onder_p01 = if_else(meting_TAW < p01,1,0),
          dag_onder_p05 = if_else(meting_TAW < p05,1,0),
          dag_onder_p10 = if_else(meting_TAW < p10,1,0),
          dag_onder_p30 = if_else(meting_TAW < p30,1,0),
          dag_boven_p01 = if_else(dag_onder_p01 == 0,1,0),
          dag_boven_p05 = if_else(dag_onder_p05 == 0,1,0),
          dag_boven_p10 = if_else(dag_onder_p10 == 0,1,0),
          dag_boven_p30 = if_else(dag_onder_p30 == 0,1,0)          
  ) %>% 
  group_by(meetpunt, simulatienr,jaar, aantaldagen_jaar, groep3, groep3n) %>% 
  summarise_at(vars(dag_onder_p01:dag_boven_p30), sum) %>% 
  ungroup() %>% 
  mutate(jaar_factor = factor(jaar)
  )

# #met opgave gw-groep
# indic_abs_basis_gw <- ruwedata %>% 
#   inner_join(absperc_gw, by = "meetpunt") %>% 
#   mutate(jaar = year(dag),
#          meetpunt = factor(meetpunt),
#          aantaldagen_jaar = if_else(jaar %in% schrikkeljaar, 366, 365 )
#   ) %>% 
#   mutate( 
#     dag_onder_p01 = if_else(meting_TAW < p01,1,0),
#     dag_onder_p05 = if_else(meting_TAW < p05,1,0),
#     dag_onder_p10 = if_else(meting_TAW < p10,1,0),
#     dag_onder_p30 = if_else(meting_TAW < p30,1,0),
#     dag_boven_p01 = if_else(dag_onder_p01 == 0,1,0),
#     dag_boven_p05 = if_else(dag_onder_p05 == 0,1,0),
#     dag_boven_p10 = if_else(dag_onder_p10 == 0,1,0),
#     dag_boven_p30 = if_else(dag_onder_p30 == 0,1,0)          
#   ) %>% 
#   group_by(groep3n, meetpunt, simulatienr,jaar, aantaldagen_jaar) %>% 
#   summarise_at(vars(dag_onder_p01:dag_boven_p30), sum) %>% 
#   ungroup() %>% 
#   mutate(jaar_factor = factor(jaar)
#   )


```
```{r rollend-gemiddelde, eval = !file.exists(file.path("cache", "dagendroog.rds" ))}
#berekenen van rollende gemiddelden

modeldata <- dagen_droog %>% 
  group_by(meetpunt, simulatienr) %>% 
  arrange(jaar) %>% 
  summarise(dag_onder_p05.0 = dag_onder_p05,
            dag_onder_p05.2 = movavg(dag_onder_p05, n = 2, "w"), #rollend gem, gewogen waarbij de gewichten een lin. trend volgen
            dag_onder_p05.4 = movavg(dag_onder_p05, n = 4, "w"),
            dag_onder_p05.6 = movavg(dag_onder_p05, n = 6, "w"),
            dag_onder_p05.8 = movavg(dag_onder_p05, n = 8, "w"),
            dag_onder_p05.10 = movavg(dag_onder_p05, n = 10, "w"),
            dag_onder_p05.20 = movavg(dag_onder_p05, n = 20, "w"),
            dag_onder_p05.30 = movavg(dag_onder_p05, n = 30, "w"),
            # dag_onder_p05.2 = movavg(dag_onder_p05, n = 2, "s"), # een ongewogen rollend gemiddelde
            # dag_onder_p05.4 = movavg(dag_onder_p05, n = 4, "s"),
            # dag_onder_p05.6 = movavg(dag_onder_p05, n = 6, "s"),
            # dag_onder_p05.8 = movavg(dag_onder_p05, n = 8, "s"),
            # dag_onder_p05.10 = movavg(dag_onder_p05, n = 10, "s"),
            # dag_onder_p05.20 = movavg(dag_onder_p05, n = 20, "s"),            
            # dag_onder_p05.30 = movavg(dag_onder_p05, n = 30, "s"),
            # dag_onder_p05.2m = movavg(dag_onder_p05, n = 2, "m"), # 'modified', 
            # dag_onder_p05.4m = movavg(dag_onder_p05, n = 4, "m"),
            # dag_onder_p05.6m = movavg(dag_onder_p05, n = 6, "m"),
            # dag_onder_p05.8m = movavg(dag_onder_p05, n = 8, "m"),
            # dag_onder_p05.10m = movavg(dag_onder_p05, n = 10, "m"),
            # dag_onder_p05.30m = movavg(dag_onder_p05, n = 30, "m"),   
            # dag_onder_p05.2t = movavg(dag_onder_p05, n = 2, "t"), # 'triangulair' gewogen
            # dag_onder_p05.4t = movavg(dag_onder_p05, n = 4, "t"),
            # dag_onder_p05.6t = movavg(dag_onder_p05, n = 6, "t"),
            # dag_onder_p05.8t = movavg(dag_onder_p05, n = 8, "t"),
            # dag_onder_p05.10t = movavg(dag_onder_p05, n = 10, "t"),
            # dag_onder_p05.30t = movavg(dag_onder_p05, n = 30, "t"),            
            # dag_onder_p05.2e = movavg(dag_onder_p05, n = 2, "e"), # 'exponentieel' gewogen
            # dag_onder_p05.4e = movavg(dag_onder_p05, n = 4, "e"),
            # dag_onder_p05.6e = movavg(dag_onder_p05, n = 6, "e"),
            # dag_onder_p05.8e = movavg(dag_onder_p05, n = 8, "e"),
            # dag_onder_p05.10e = movavg(dag_onder_p05, n = 10, "e"),
            # dag_onder_p05.30e = movavg(dag_onder_p05, n = 30, "e"),
            jaar = jaar
            ) %>% 
  ungroup() 

#omzetten naar integers (nodig voor binomiale verdelingen)
modeldata <- modeldata %>% 
  mutate_if(is.numeric, as.integer)

dagen_droog <- dagen_droog %>% 
  inner_join(modeldata)

#wegschrijven in een RDS-bestand
saveRDS(dagen_droog,file.path("cache", "dagendroog.rds" ))
saveRDS(modeldata,file.path("cache", "modeldata.rds" ))
```

```{r abs-indicator-uit-cache}
dagen_droog <- readRDS(file.path("cache", "dagendroog.rds" ))
modeldata <- readRDS(file.path("cache", "modeldata.rds" ))
```

### Verdeling van de indicator {#h4-1-2:verdeling-indicator}

De techniek die we wensen toe te passen bij de modelbouw is parametrisch: ze vereist dat er assumpties gemaakt worden over de verdeling van de afhankelijke variabele.

We beschikken voor elk jaar en meetpunt over twintig simulaties.
Dit laat in zekere mate toe de verdeling ervan te bestuderen.

In theorie is de indicator te beschouwen als een discrete variabele. 
Het feit dat er een kritische drempelwaarde is die al dan niet overschreden wordt en het aantal dagen van een jaar (= aantal 'pogingen') vast ligt, wijzen in de richting van een binomiale verdeling met n = 365 of 366 en $\pi$ = 0,05.

Een probleem is dat één belangrijke conditie voor het gebruik van een verdeling wordt geschonden. 
De 'trekkingen' gebeuren namelijk niet onafhankelijk van elkaar: de kans dat als het vandaag een droge dag is, het dat morgen of overmorgen ook zal zijn is veel groter dan 0,05 en vice versa. 
Modellen die uitgaan van een binomiale of een andere verdeling gaan er van uit dat dit wel zo is. 
We hebben onderzocht of in de dataset de indicator binomiaal verdeeld is door de 

Daarom werd de verdeling van de indicator niet alleen vergeleken met de negatief-binomiale, maar ook met de poisson- en de binomiale verdeling. 

Voor deze vergelijking werd gebruikt gemaakt van zogenaamde QQ-plots. 
Een QQ-plot zet de kans uit dat een bepaalde waarde of kleiner uit een bepaalde verdeling wordt getrokken uit ten opzichte van de percentielwaarde van deze waarde.

De verdelingen werden steekproefgewijs getest op een aantal meetpunten en jaren. 
Deze testen gaven aan dat de verdeling vrij goed overeenkwam met de binomiale of negatief binomiale verdeling. 
De overeenkomst met de poisson-verdeling was meestal relatief iets minder goed.


```{r check-distribution-qq}

checkdistributie <- dagen_droog %>% 
                                 filter(jaar == 2006, meetpunt == "ASBP003") %>% #ALMP003 ASBP003 BTRP001 COOP001 DYLP029 GSCP017
        dplyr::pull(dag_onder_p05)

```

De figuren \@ref(fig:check-qq-poisson), \@ref(fig:check-qq-nbinom) en \@ref(fig:check-distribution-qq-binom) geven een voorbeeld van een QQ-plot voor resp. de poisson, de negatief-binomiale en binomiale verdeling.

```{r check-qq-poisson, fig.cap = "QQ-plot poisson-verdeling"}

poisson <- MASS::fitdistr(checkdistributie, "Poisson")
car::qqp(checkdistributie, "pois", lambda = poisson$estimate, id = FALSE)

```

```{r check-qq-nbinom, fig.cap = "QQ-plot negatief binomiale-verdeling"}

nbinom <- MASS::fitdistr(checkdistributie, "Negative Binomial")
qqPlot(checkdistributie, "nbinom", size = nbinom$estimate[[1]], mu = nbinom$estimate[[2]], id = FALSE)

```

```{r check-distribution-qq-binom, fig.cap="QQ-plot binomiale-verdeling"}
invisible(capture.output(binom <- fitdistrplus::fitdist(checkdistributie, "binom", fix.arg = list(size = 365), start = list(prob = 0.05))
))
#summary(binom)

  qqp(checkdistributie, "binom", size = 365, prob = binom$estimate, id = FALSE)


```


```{r check-distribution boxplot, eval = FALSE}
boxplot(checkdistributie/365)

#ggplot(data = checkdistributie, aes(dag_onder_p01)) + geom_histogram() 
#ggplot(data = data.frame(checkdistributie), aes(dag_onder_p05)) + geom_histogram() 
#ggplot(data = checkdistributie, aes(dag_onder_p10)) + geom_histogram()  
#ggplot(data = checkdistributie, aes(dag_onder_p30)) + geom_histogram()
```

Wanneer we echter een model bouwen met een indicator met een binomiale verdeling, dan blijkt een dergelijk model te kampen met overdispersie.
Dit treedt op wanneer de variantie die op basis van een binomiale verdeling verwacht wordt duidelijk kleiner is dan de waargenomen variantie. 
Gaan we voor de modelbouw uit dat de indicator negatief binomiaal verdeeld is, blijkt de overdispersie veel beter binnen de perken.
Er wordt daarom gekozen om negatief binomiale modellen te bouwen.

```{r check, eval=FALSE}
check <- dagen_droog %>% 
  group_by(meetpunt) %>% 
  count()
```



