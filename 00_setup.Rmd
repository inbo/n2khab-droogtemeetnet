<!-- #setup -->
```{r include=FALSE}
knitr::opts_chunk$set(
	eval = FALSE,
	dpi = 300,
	include = FALSE,
  cache = TRUE,
  cache.path = "cache/"	
)
# opts_chunk$set(
#   echo = FALSE,
#   dpi = 300
# )
options(stringsAsFactors = FALSE)
# library(plyr)

library(stringr)
library(knitr)
library(sf)
library(units)
library(git2rdata)
library(lubridate)

# install watina-package branch develop_fv
# remotes::install_github("inbo/watina",
#                         ref = "develop_fv")
library(watina)
# install n2khab-package
# remotes::install_github("inbo/n2khab",
#                         build_opts = c("--no-resave-data", "--no-manual"))
library(n2khab)
library(raster)
library(tmap)
library(tidyverse)
library(kableExtra)
library(knitr)
library(googledrive)
library(RSQLite) 
```

```{r constanten, eval= TRUE, include= TRUE, echo= FALSE}
#gewenste grootte van het meetnet
tot_n_tub <- 100

#aantal stratificatielagen
aantal_strat <- 5

#verdeling meetpunten over de stratificatielagen
minaantal_tub_group <- as.integer(tot_n_tub/aantal_strat)

#kwaliteitscriteria meetreeksen
  #minimale lengte van de tijdreeks 
  minlength <- 5
  #maximale duur van een onderbreking van de tijdreeks 
  maxgap <- 2
  #binnen een tijdreeks minimaal aantal meetjaren waarvoor een lg3 kan berekend worden
  minnryears <- 5
  
  #aanvullende criteria om meetreeksen te vergelijken
  toelaatbare_spreiding_jaren <- 5
  toelaatbaar_verschil_lengte_tijdreeks <- 5

#zoekstraal rond peilbuizen (buffer)
bufferpb <- 3 

#peilbuizen niet zeker niet kunnen opgenomen worden, bijv. geen toelating, omdat het te dicht bij een ander geselecteerd punt ligt
#uitgesloten_tubes <- c("MOSP001", "HALP005", "BUIP027")
uitgesloten_tubes <- "leeg"

```

```{r read-databases, eval= FALSE, include= TRUE, echo= FALSE}
gw_types <- read_scheme_types(lang = "nl") %>%
    filter(scheme == "GW_05.1_terr") %>%
    arrange(typegroup) %>%
    mutate(groupnr = as.integer(str_sub(typegroup, -1))) %>% 
    dplyr::select(type, groupnr, typegroup_name)
output_vc <- write_vc(gw_types, file.path(".","data","gw_types"), sorting = c("type"), strict =  FALSE)

types <- read_types(lang = "nl")
output_vc <- write_vc(types, file.path(".","data","types"), sorting = c("type"), strict =  FALSE)


rm(output_vc)

```

```{r read-gisdata, eval= FALSE, include= TRUE, echo= FALSE}
habmap_terr <- read_habitatmap_terr()

habmap_polygons <- habmap_terr$habitatmap_terr_polygons

habmap_patches <- habmap_terr$habitatmap_terr_patches
# habfile <- "20_processed/habitatmap_terr/habitatmap_terr.gpkg"
# 
# habmap_stdized <- read_habitatmap_stdized(file = habfile)
# 
# habmap_polygons <- habmap_stdized$habitatmap_polygons
# 
# habmap_patches <- habmap_stdized$habitatmap_patches

habmap_patches <- habmap_patches %>%
    mutate( polygon_id = as.factor(.data$polygon_id),
            patch_id = as.numeric(.data$patch_id),
            certain = .data$certain == 1,
            type = factor(.data$type,
                          levels = levels(types$type)
                          )
            )

# Verspreiding van de verdrogingsgevoelige typen in Vlaanderen volgens de habitatkaart.
habmap_patches_gw <- habmap_patches %>% 
  inner_join(gw_types, by = c("type" = "type"))

habmap_polygons_gw <- 
  habmap_polygons %>% 
      inner_join(habmap_patches_gw %>% 
                   dplyr::select(-code_orig), 
                by = "polygon_id")



#wegschrijven als geopackage
datapath <- "G:/Mijn Drive/PRJ_Meetnet_Droogte/2_Uitvoering/data"
dir.create(file.path(datapath, "GIS/VoorR/"), recursive = TRUE)

st_write(habmap_polygons_gw,
         file.path(datapath, 
                   "GIS/VoorR/habmap_terr_gw.gpkg"), 
         layer = "habitatmap_terr_polygons_gw", 
         driver = "GPKG",
         delete_dsn = TRUE)

con = dbConnect(SQLite(),
                dbname = file.path(
                  datapath, 
                  "GIS/VoorR/habmap_terr_gw.gpkg")
                )

dbWriteTable(con, "habitatmap_terr_patches_gw", habmap_patches_gw)



#GRTS-data
raster_meetnet_poly <- read_GRTSmh_diffres(level = 8, polygon = TRUE)

dbWriteTable(con, "raster_meetnet_poly", raster_meetnet_poly)


#overlay maken hab-kaart en GRTS-rooster
habmap_gw_raster_overlay <- habmap_polygons_gw %>% 
  st_intersection(raster_meetnet_poly)

habmap_gw_raster_overlay <- habmap_gw_raster_overlay %>% 
    mutate(opp = as.integer(st_area(habmap_gw_raster_overlay))) 

#wegschrijven van deze intersectie


dbWriteTable(con, "habmap_gw_raster_overlay", habmap_gw_raster_overlay)
dbDisconnect(con)

#inlezen grts-raster level 1 (hoogste resolutie = kleinste gridcelgrootte)
grts_level1 <- read_GRTSmh(brick = TRUE) %>% 
  raster::subset(1)

#inlezen grts-raster level 9 (resolutie = raster_meetnet_poly), het heeft een gridgrootte van 8192 m, let wel de rastercelgrootte is ook hier 32 bij 32m, dus het aantal rastercellen = grts-raster level 1. 
grts_level9 <- read_GRTSmh(brick = TRUE) %>% 
  raster::subset(9)

writeRaster(grts_level9,
            filename = file.path(datapath, "GIS/VoorR/grts_level9.tif"), 
            format = "GTiff", 
            datatype = "INT4S",
            overwrite = TRUE)

writeRaster(grts_level1,
            filename = file.path(datapath, "GIS/VoorR/grts_level1.tif"), 
            format = "GTiff", 
            datatype = "INT4S",
            overwrite = TRUE)



```


```{r read-watina-data, eval= FALSE, include= TRUE, echo= FALSE}
watina <- connect_watina()
tubes_hab <- get_locs(watina, mask = habmap_gw_raster_overlay, join_mask = TRUE,
                      buffer = bufferpb, loc_type = "P", loc_validity = c("VLD", "ENT"), collect = TRUE)


#beperken van peilbuizen tot de rastercel waar ze effectief in liggen. Door het gebruik van een buffer is het immers mogelijk dat een peilbuis in twee of meer cellen komt te liggen.
tubes_hab_sf <- as_points(tubes_hab)

#overlay van peilbuizen met het raster
tubes_hab_gw_raster_overlay <- tubes_hab_sf %>% 
  distinct(loc_code, x, y) %>% 
  st_intersection(raster_meetnet_poly)

tubes_hab <- tubes_hab %>% 
  semi_join(tubes_hab_gw_raster_overlay, by = c("loc_code","rasterid"))

#save tubes_hab as a git2rdata-object
tubes_hab <- tubes_hab %>% 
  arrange(loc_code, polygon_id, rasterid, patch_id, type)

output_vc <- write_vc(tubes_hab, file.path(".","data","tubes_hab"), sorting = c("loc_code", "polygon_id", "rasterid", "patch_id", "type" ), strict =  FALSE)
rm(output_vc)


tubes_xg3 <- tubes_hab %>% 
    get_xg3(watina, startyear = year(now()) - 18, endyear = 2016, vert_crs = "local",
            truncated =  TRUE, collect = TRUE)

#oplossen van UTF-probleem: strings worden in inbo-SQL-databanken opgeslagen in UTF-16, terwijl hier gewerkt wordt met UTF-8. Dit geeft een probleem bij de kable-functie

#tubes_xg3 <- mutate_if(tubes_xg3, is.character, iconv, to = "UTF-8")

tubes_xg3 <- tubes_xg3 %>% 
  arrange(loc_code, hydroyear)

output_vc <- write_vc(tubes_xg3, file.path(".","data","tubes_xg3"), sorting = c("loc_code", "hydroyear"),
         strict =  FALSE, root = ".")


DBI::dbDisconnect(watina)

#volgende watina-functie werkt ook zonder databankconnectie, maar omdat deze op sommige pc's niet stabiel werkt, worden de data hier alvast lokaal weggeschreven.

tubes_lg3_eval <- tubes_xg3 %>%
  eval_xg3_series(xg3_type = c("L"),
                  max_gap = maxgap,
                  min_dur = minlength)

tubes_lgl_eval <- tubes_lg3_eval %>%
    filter(ser_nryears >= minnryears)

output_vc <- write_vc(tubes_lgl_eval, file.path(".","data","tubes_lgl_eval"), sorting = c("loc_code", "hydroyear"),
         strict =  FALSE, root = ".")

rm(output_vc)
```

