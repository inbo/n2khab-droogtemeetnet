---
title: "Een indicator voor het opvolgen van droogte in ondiepe grondwaterlagen binnen natuurgebieden"
author: 
  - 
    name: "Jan Wouters"
    email: "jan.wouters@inbo.be"
  - 
    name: "Floris Vanderhaeghe"
    email: "floris.vanderhaeghe@inbo.be"
#subtitle: "Hier komt de optionele ondertitel"
reportnr: "Hier komt de DOI van het rapport"
# ordernr: "Het optionele nummer van de opdrachtgever"
bibliography: JanWouters.bib
link-citations: TRUE
site: bookdown::bookdown_site
params:
  refresh_data: 2
  refresh_figures: 2
output:
  bookdown::gitbook:
    split_by: "chapter+number"
    template: !expr INBOmd::inbo_rapport_css("html")
    pandoc_args: !expr c("--csl", system.file("research-institute-for-nature-and-forest.csl", package = "INBOmd"))
  bookdown::pdf_book:
    base_format: INBOmd::inbo_rapport
    citation_package: "none"
    #base_format: mijneerstepackage::inbo_rapport_jw
    style: INBO
    tocdepth: 2
    lof: TRUE
    lot: TRUE
    floatbarrier: subsection
  bookdown::epub_book:
    stylesheet: "css/inbo_rapport.css"
    template: !expr INBOmd::inbo_rapport_css("epub")
    pandoc_args: !expr c("--csl", system.file("research-institute-for-nature-and-forest.csl", package = "INBOmd"))
---



```{r setup, include = FALSE}
library(knitr)
opts_chunk$set(
  echo = FALSE,
  eval = TRUE,
  include = TRUE,
  cache = TRUE,
  cache.path = "cache/",  
  fig.width = 200 / 25.4, #lengte en breedte worden uitgedrukt in inches => 150 mm
  fig.height = 100 / 25.4,
  warning = TRUE,
  error = FALSE,
  message = TRUE
)
library(tidyverse)
library(INBOtheme)
if (interactive()) {
  theme_set(
    theme_inbo(
      base_family = "Calibri", # "FlandersArtSans-Regular",
      base_size = 10
    )
  )
} else {
  switch(
    opts_knit$get("rmarkdown.pandoc.to"),
    html = {
      opts_chunk$set(dev = "png", dpi = 72)
      theme_set(
        theme_inbo(
          base_family = "Calibri", # "FlandersArtSans-Regular",
          base_size = 12
        )
      )
    },
    latex = {
      opts_chunk$set(dev = "cairo_pdf", dpi = 300)
      theme_set(
        theme_inbo(
          base_family = "Calibri", # "FlandersArtSans-Regular",
          base_size = 9
        )
      )
      update_geom_defaults("point", list(size = 1.5))
    },
    epub3 = {
      opts_chunk$set(dev = "png", dpi = 300)
      theme_set(
        theme_inbo(
          base_family = "Calibri", # "FlandersArtSans-Regular",
          base_size = 12
        )
      )
    }
  )
}
```

<!--chapter:end:index.Rmd-->

<!-- #setup -->
```{r lib-param, include=FALSE}
options(stringsAsFactors = FALSE)

#belangrijke opmerking: run dit programma in de 64-bit versie van R
#Tijdens de uitvoering van het programma in de 32-bit versie van R ontstonden er op mijn laptop geheugenproblemen.
library(knitr)
library(kableExtra)
library(INBOmd)
library(tidyverse)
library(INBOtheme)
library(odbc)
library(DBI)
library(git2rdata)
library(lubridate)
library(MASS)
library(car)
library(lme4)
library(INLA)

# ingesteld in index.Rmd
# output_format <- ifelse(
#   interactive(),
#   "html",
#   opts_knit$get("rmarkdown.pandoc.to")
# )

#keuzen voor het aanmaken van een document
#welke data verversen
# 2: alles; 1: enkel de huidige google-drive-bestanden downloaden ; 0: enkel met lokale data
if (params$refresh_data == 2) {
  datapath <- "G:/Mijn Drive/PRJ_Meetnet_Droogte/2_Uitvoering/data"
  dir.create(file.path(datapath, "GIS/VoorR/"), recursive = TRUE)
}

#figuren opnieuw aanmaken of inlezen
# 2: figuren terug aanmaken (en wegschrijven); 1: de huidige figuren van google-drive downloaden, 0: alleen lokale figuren inlezen
if (params$refresh_figures == 2) {
  figpath <- "G:/Mijn Drive/PRJ_Meetnet_Droogte/2_Uitvoering/figuren"
}

# lokale gitignored paden aanmaken
if (!dir.exists(file.path("..", "data", "local"))) dir.create(file.path("..", "data", "local"), recursive = TRUE)
if (!dir.exists(file.path("..", "figures", "local"))) dir.create(file.path("..", "figures", "local"), recursive = TRUE)

pdfmaken <- FALSE

```

```{r constanten, include= FALSE}


```

```{r read-databases, include= FALSE}
if (params$refresh_data == 2) {

}
```

```{r read-gisdata, include= FALSE}
if (params$refresh_data == 2) {
  
}
```


<!--chapter:end:00_setup.Rmd-->

# Inleiding {#h1:inleiding}
Driekwart van de voor Vlaanderen en Europa meest waardevolle natuurtypes, steunen voor hun voortbestaan op grondwater. Grondwaterafhankelijke vegetaties komen voor in en op de rand van kwelgebieden, beekvalleien, vijvers en poelen. 
De vochtige gebieden vertonen vaak veel gradiÃ«nten en herbergen daarom een hoge biodiversiteit (De Becker, 2020). 
Als het grondwater door verdroging van samenstelling verandert, of systematisch buiten het bereik van de plantenwortels en de bovengrondse delen van waterplanten valt, krijgen typische soorten het moeilijk. 
Slagen die soorten er niet in om zich aan te passen of om hun leefgebied te verschuiven, dan dreigen ze te verdwijnen. 
Dat risico wordt groter als bijvoorbeeld het landgebruik of het grondwaterregime in de omgeving de beschikbare ruimte om uit te wijken beperkt. 

# Monitoring droogte in Vlaanderen {#h2:monitoring}
Monitoring is het op regelmatige tijdstippen gestandaardiseerd beschrijven van een maatstaf. 
Deze maatstaf moet toelaten om een bepaalde doelstelling of toestand te beoordelen.
Toegepast op dit onderzoek, wil dit zeggen dat we een droogte-indicator zoeken, waarmee de droogte op een gestandaardiseerde wijze in droogtegevoelige locaties/vegetaties in Vlaanderen op jaarbasis kan opgevolgd worden.

Een gestandaardiseerde wijze wordt in dit onderzoek beschouwd als een vast aantal meetpunten waar het grondwaterpeil op reguliere basis op een uniforme manier wordt gemeten.
Het vast aantal meetpunten krijgt vorm door middel van een meetnet (zie \@ref(h2-1:meetnet)).
Om droogte adequaat en zo precies mogelijk te kunnen opvolgen, menen we dat dagelijkse metingen aangewezen zullen zijn.
Als maatstaf gaan we op zoek naar een gepaste droogte-indicator (zie \@ref(h2-2:indicator)).

## Droogtemeetnet {#h2-1:meetnet}
Om in Vlaanderen een globaal beeld te krijgen van de evolutie van de grondwaterstanden op middellange tot lange termijn in verdrogingsgevoelige vegetaties werd een meetnet van een honderdtal punten ontworpen. 
Op schaal Vlaanderen is dit een relatief laag aantal. 
Wil men op deze schaal veralgemeenbare uitspraken kunnen maken, moet de keuze van deze punten zo goed mogelijk ruimtelijk gebalanceerd gebeuren. 
Ook moet er rekening gehouden worden met mogelijke verschillen in het gedrag van het grond/oppervlaktewaterpeil t.a.v. een neerslagtekort. 
@RN6212 geven een toelichting hoe dit meetnet concreet werd ontworpen. 

## Droogte-indicatoren {#h2-2:indicator}
Een volgende vraag die zich stelt, is een goede maat te vinden voor het bepalen van droogte in verdrogingsgevoelige vegetaties.
Deze maat is onder andere afhankelijk van de gewenste doelstelling. 
Zo kunnen bijv. de maten verschillen voor het vaststellen van de eerste tekenen van droogte en voor een algemeen beeld van droogte op jaarbasis. 
In dit rapport wordt een indicator gezocht voor deze laatste doelstelling. 
Ze moet dus toelaten om op jaarbasis de algemene droogte-toestand van verdrogingsgevoelige vegetaties weer te geven. 
Drie soorten indicatoren werden hiervoor in beschouwing genomen:

- een *cumulatieve*: **de som per jaar van de diepte van het grondwaterpeil beneden een kritische drempelwaarde** 

- een *absolute*: **aantal dagen per jaar dat het grondwaterpeil beneden een kritische drempelwaarde is**

- een *relatieve*: **aantal relatief droge dagen per jaar** 
Een relatief droge dag is een dag waarbij het grondwaterpeil lager staat dan een bepaalde percentielwaarde voor die dag in een bepaalde periode.
We gaan verder in dit hoofdstuk wat dieper in op de beweegredenen om  voor de beleidsrapportering een absolute indicator te verkiezen. 

### Bepalen referentietoestand {#h2-2-1:referentietoestand}
Een indicator vergelijkt een bepaalde toestand met een referentietoestand. 
Bij het bepalen van de referentietoestand spelen twee factoren een rol:

- welk grondwaterpeil beschouwen we als indicatief voor droogte oftewel wat is een **kritische waarde**?

- welk **tijdsvenster** hanteren we hierbij als referentie?

Als kritische drempelwaarde nemen we het grondwaterpeil dat 'normaal' op minder dan 5% van de dagen van een jaar (dit is afgerond 18 dagen) onderschreden wordt. 
Een droge dag is een dag dat het grondwaterpeil onder deze kritische drempelwaarde is. Een droog jaar is een jaar met meer dan 18 droge dagen.

Deze drempelwaarde stemt nauw overeen met de hydrologische variabele 'gemiddeld laagste grondwaterstand' (GLG) [@RN5703]. 
Dit is het gemiddelde van de drie laagste grondwaterpeilen op een jaar, met een minimum verschil van 14 dagen tussen de metingen, en dit uitgemiddeld over een zekere tijdsperiode: standaard een achttal jaar [@RN5875].
Voor vele verdrogingsgevoelige vegetaties is de GLG een belangrijke standplaatsfactor, zie bijv. [@RN4269; @RN4829; @RN5975].
De reden waarom dan niet de GLG als kritische drempelwaarde werd gekozen, ligt hem in het feit dat er een minimumaantal dagen tussen de waarnemingen moet zitten.
Dit bemoeilijkt het werken met tijdreeksen van dagelijkse metingen. 

Het tijdsvenster is een andere belangrijke factor bij het vastleggen van een referentie.
Men heeft dan te bepalen of gewerkt wordt met een vast tijdskader (van jaar a tot jaar b) of een relatief tijdkader (bijv. de laatste x jaren).
Ook de lengte van de tijdsperiode is een keuze die men moet maken.
We kiezen hier voor een vast tijdvenster van 30 jaar, nl. 1985 tot en met 2014.
Een periode van dertig jaar is gebruikelijk in klimaatstudies. 
De reden dat we voor een vast venster kiezen, is dat de trend gemakkelijker te interpreteren is. 
Ook het KMI werkt met vaste vasters, die ze periodiek herziet.
Het venster kan na bijv. vijftien jaar worden herzien: dus bijv. vanaf 2035 kan 2000 - 2029 als nieuw referentie genomen worden).
De periodieke herijking laat toe om de meer recente evolutie beter in beeld te brengen.

### Keuze indicator {#h2-2-2:indicator}

De drie soorten kandidaat-indicatoren werden onderling afgewogen op basis van twee karakteristieken:

- de ecologische duiding
- kan er een referentieniveau voor bepaald worden ?

De grondwaterstand kan een directe of indirecte invloed hebben op een aantal balansen die belangrijk zijn voor de fysiologie van een plant:

- waterbalans
- mineralenbalans
    - aanvoer van (essentiÃ«le) mineralen / zouten
    - invloed op biogeochemische processen die de beschikbaarheid van mineralen bepalen
- nutriÃ«ntenbalans
    - aanvoer van nutriÃ«nten
    - invloed op biogeochemische processen die de beschikbaarheid van nutriÃ«nten bepalen
- zuurstofbalans
    - (on)beschikbaarheid van zuurstof
    - invloed op biogeochemische processen die de beschikbaarheid van toxische stoffen bepalen
    
Een cumulatieve en een absolute droogte-indicatoren toetsen een grondwaterpeil af met een vast referentiepeil.
Ze hebben een ecologische betekenis, omdat ze uitdrukking geven aan mogelijke wijzigingen in Ã©Ã©n of meer van bovenvermelde balansen die met een peilswijziging gepaard gaan.

Een relatieve indicator [^gwindic] is niet gekoppeld aan een vast referentiepeil. 
Het referentiepeil hangt samen met de dag van het jaar.
In die zin is de ecologische betekenis ervan minder Ã©Ã©nduidig. 
Om die reden valt een relatieve indicator af als een kandidaat indicator.

Blijft dan nog de keuze tussen een cumulatieve en een absolute droogte-indicator.
De cumulatieve geeft nog iets beter de sterkte van een eventueel voorkomende droogte aan, doordat het niet alleen rekening houdt met het aantal dagen dat het grondwaterpeil onder een referentiepeil bevindt, maar ook met de graad dat dit het geval is.
Een cumulatieve indicator heeft echter als nadeel dat het moeilijk is om een indicatorwaarde te definiÃ«ren die droge jaren van niet-droge jaren kan onderscheiden. 
Een absolute indicator laat dat wel toe.
Zo ligt, zoals hoger al werd aangehaald, het referentieniveau of baseline bij een absolute indicator o.b.v. 5% drempelwaarde op 18 dagen. Een jaar met meer dan 18 droge dagen kan als een relatief droog jaar worden beschouwd.

Conclusie:
Voor de gewenste doeleinde is een absolute droogte-indicator gebaseerd op de 5% drempelwaarde het meest aangewezen.


[^gwindic]: Ã©Ã©n van de [grondwaterstandsindicatoren](https://www.vmm.be/data/grondwaterstandindicator) van de VMM is een voorbeeld van een relatieve indicator. 




<!--chapter:end:01_Inleiding.Rmd-->

# Werkwijze berekening droogte-indicator {#h3:methode}

Het toekomstig droogte-meetnet zal uit een honderdtal meetpunten bestaan. 
Op 58 van de geselecteerde locaties wordt het grondwaterpeil reeds verschillende jaren gemeten.

De berekening bevat vier delen:

- vervolledigen tijdreeksen
- berekenen van de kritische drempelwaarde voor elk van de meetlocaties
- berekenen van de droogte-indicator
- berekenen van de evolutie/trend van de droogte-indicator

## Vervolledigen tijdreeksen {#h3-1:tijdreeks}

Zoals in \@ref(h2-2-1:referentietoestand) werd aangehaald, willen we werken met een vast referentietijdsvenster: 1985 -  2014.
Voor geen enkele van de geselecteerde meetpunten beschikken we echter voor deze tijdsperiode over volledige tijdreeksen, t.t.z. 30 jaar * 365 metingen/jaar.

Een selectiecriterium om als meetpunt in het meetnet te kunnen worden opgenomen, was dat het verloop van de grondwaterstanden in belangrijke mate (minstens 2/3 van de variatie) kan verklaard worden door de meteorologische variabelen: neerslag en potentiÃ«le evapotranspiratie [@RN6212].
Deze eigenschap kunnen we gebruiken om ontbrekende data in de tijdreeks aan te vullen.
Hiervoor doen we een beroep op het softwareprogramma Menyanthes [@RN5899].
Het programma kan op basis van verklarende reeksen zoals neerslag en potentiÃ«le evapotranspiratie een model bouwen waarmee grondwaterpeilen kunnen worden geschat.

Voor elk van de 58 meetlocaties werd op deze basis een model gebouwd.
Met dit model werden vervolgens 20 simulaties berekend voor de periode 1985 - 2018, dus niet alleen voor de referentieperiode. 
Een effectieve veldmeting kreeg hierbij voorrang op een modelwaarde.
Dit betekent dat op dagen met werkelijke metingen de 20 reeksen steeds dezelfde waarde, nl. die van de veldmeting, zullen hebben.
Deze verschillende simulaties zullen toelaten om de onzekerheid te schatten die er bestaat voor de dagen zonder veldmeting. 

## Berekenen van de krtitische drempelwaarden {#h3-2:drempelwaarde}

Zoals in \@ref(h2-2-1:referentietoestand) besproken werd, stellen we als kritische drempelwaarde het grondwaterpeil dat 'normaal' op minder dan 5% van de dagen van een jaar (dit is afgerond 18 dagen) onderschreden wordt. 
Het ontbreekt hier nog aan duiding over wat als 'normaal' of als referentie wordt beschouwd. 
Hiervoor kijken we naar het referentietijdsvenster (1985 - 2014) en berekenen we voor elk meetlocatie de kritische drempelwaarde als het gemiddelde van de 5%-percentiel van de grondwatermetingen van een jaar binnen de periode 1985 - 2014. 
Het is dus niet de absolute percentielwaarde op alle metingen van 30 jaar. 
Stel bijvoorbeeld dat er Ã©Ã©n heel droog jaar is, waarbij de 5% droogste peilen in dat jaar vallen, dan zou kritische drempelwaarde louter op dat ene uitzonderlijke jaar gebaseerd zijn.
Dit beschouwen we als niet representatief, ook omdat de responstijd van vegetaties op wijzigende grondwaterregimes langzamer is dan Ã©Ã©n jaar. Daarom wordt hier verkozen om te werken met een gemiddelde van percentielwaarden per jaar. 
Deze werkwijze is ook analoog aan het berekenen van karakteristieke grondwaterstanden (GXGâs) voor vegetaties [@RN5875].


## Berekenen van de droogte-indicator {#h3-3:indicator}

Kennen we de kritische drempelwaarde dan kan de droogte-indicator vrij eenvoudig berekend worden.
Eerst tellen we voor elke meetlocatie, elk jaar en elke simulatie het aantal dagen dat het grondwaterpeil onder de kritische drempelwaarde is $=dagen\_droog_{meetlocatie_m; simulatie_s; jaar_j}$. 
Voor de periode 1985 - 2018, 58 meetlokaties en 20 simulaties betekent dit dus 34 * 58 * 20 = 39440 ${\textstyle {dagen_droog}}$-waarden

```{block2 definitie-droogte-indicator, type="exampleblock", latex.options="{}", echo = TRUE}
De droogte-indicator voor een bepaald jaar $j$ is dan het gemiddelde van deze aantallen droge dagen voor alle simulaties en meetlocaties: ${\text {droogte-ind}}_{j} = \frac{\sum_{s=1}^{20}\sum_{m=1}^{58}{\textstyle {dagen_droog}}_{m;s;j}}{20*58}$

```

Momenteel wordt de droogte-indicator berekend op basis van 58 meetlocaties. 
Er zijn er echter een honderdtal voorzien.
Mettertijd zal de droogte-indicator op een groter aantal punten berekend worden. 
Het mogelijke effect op de indicatorwaarden zal ingeschat worden door ook de waarde voor de huidige 58 locaties te blijven berekenen.

Het wordt complexer als we inzicht willen krijgen in de onzekerheid die er op de droogte-indicator zit, m.a.w. wat is het betrouwbaarheidsinterval van de droogte-indicator ? 

Hiervoor doen we een beroep op de formule van Rubin [@RN6220].
We geven eerst de inhoudelijke betekenis, Vooraleer we de mathematische uitwerking geven.
De totale variantie in de data kan beschouwd worden als een optelling van twee varianties, een variantie die inherent is aan de data en een bijkomende variantie die voorvloeit uit de onzekerheid over de schatting van ontbrekende waarden (= variantie door imputatie).
In het geval van de droogteindicator wordt (voor Ã©Ã©n bepaald jaar) de variantie die inherent is aan de data geschat op basis van de verschillen in de indicatorwaarden tussen de meetpunten.
De variantie door imputatie wordt geschat op basis van de verschillende simulaties. 
Deze is vooral bepaald door voor de simulaties de afwijkingen tussen de indicatorwaarden te berekenen.

Kennen we de variantie kan hiermee, op basis van de centrale limietstelling, voor elk jaar een betrouwbaarheidsinterval berekend worden.

Mathematisch wordt het betrouwbaarheidsinterval door de hieronder gegeven formules berekend. 

$${\textstyle {de droogte-indicator voor Ã©Ã©n simulatie en Ã©Ã©n jaar : droogte-ind-sim}}_{j;s} =  \sum_{m = 1}^{58}({\textstyle {dagen_droog}}_{m;s;j}) / 58 $$
$${\textstyle {de droogte-indicator voor Ã©Ã©n jaar : droogte-ind}}_{j} =  \sum_{s = 1}^{20}(\frac{\sum_{m=1}^{58}{\textstyle {dagen_droog}}_{m;s;j}}{58}) / 20 $$

$$ \bar\sigma^2_{{\textstyle {droogte-ind}}_{j}} = \frac{\sum_{s = 1}^{20}\widehat{\sigma}^2_{{\textstyle {droogte-ind-sim}}_{j;s}}}{20} + (1 + 1/20)*\frac{\sum_{s=1}^{20}({\textstyle {droogte-ind-sim}}_{j;s} - {\textstyle {droogte-ind}}_{j})^2}{(20 - 1)}$$

De ondergrens van het betrouwbaarheidsinterval (LCL) voor een bepaald jaar $j$ wordt dan :

$$ {\textstyle {LCL}}_j = {\textstyle{droogte-ind}}_{j} - 1.96 * \sqrt{\bar\sigma^2_{{\textstyle {droogte-ind}}_{j}}}$$

De bovengrens van het betrouwbaarheidsinterval (UCL) voor een bepaald jaar $j$ wordt dan :

$$ {\textstyle {UCL}}_j = {\textstyle{droogte-ind}}_{j} + 1.96 * \sqrt{\bar\sigma^2_{{\textstyle {droogte-ind}}_{j}}}$$


## Berekenen van de evolutie/trend van de droogte-indicator {#h3-4:trend}

Om de trend in de droogte-indicator over de jaren heen te detecteren, wordt een tijdreeksanalyse uitgevoerd. 


Voor elke simulatie verloopt die berekening als volgt: een Bayesiaans mixed model, met een zero-inflated negatieve binomiale verdeling en jaar als factor schat de kans in dat een gesimuleerde dagwaarde zich onder de drempel bevindt. 
Het effect van de factor âjaarâ wordt beschreven door een random walk-functie van de tweede orde. 
Meer informatie over dergelijke modellen is o.a. te vinden in @RN6221

Per jaar (en simulatie) wordt een gemiddelde waarde met haar standaardafwijking berekend. 
In tegenstelling met ${\textstyle {droogte-ind}}_{j}$ worden aan die berekening voorwaarden gekoppeld, namelijk dat het effect van een jaar afhangt van de vorig(e) jaar/jaren volgens een tweede orde functie en ook dat een meetpunt een vaste (maar onbekende) bijdrage levert (dus dat meetpunten systematisch droger of natter kunnen zijn).
$${\textstyle {dagen_droog}}_{m;s;j} \sim NB(\overline{{\textstyle {droogte-ind-sim}}}_{j;s}, \theta)  $$

$$\overline{{\textstyle {droogte-ind-sim}}}_{j;s} = E({\textstyle {dagen_droog}}_{m;s;j}) \sim {\textstyle {jaar}} + (1 \vert{\textstyle{meetlocatie}})  $$
of 

$$\log(\overline{{\textstyle {droogte-ind-sim}}}_{j;s}) = \beta_0 + \beta_1T_j + t_j + b_m + \epsilon_{jm}$$
$\beta_0$ is de intercept

$\beta_1T_j$ is het specifiek effect/bijdrage van een jaar

$t_j$ is een term ('random walk') die toelaat om rekening te houden met het feit dat het effect van het ene jaar mogelijk afhankelijk is van dat van Ã©Ã©n of meer van de voorgaande jaren.

Hier beschrijven we die mogelijke afhankelijkheid als een twee-orde relatie:
$$ \Delta^2 t_i = \Delta t_{i+1} - \Delta t_i = t_{i+1} - 2t_i + t_{i-1}$$
$$ \Delta^2 t_i \sim  N(0,\sigma^2)$$

$b_m$ is het mogelijke systematische effect van een meetpunt. 
We nemen aan dat deze effecten normaal verdeeld zijn: $b_m \sim N(0, \sigma _m)$.
Doordat voor elk meetpunt er op basis van de referentieperiode een specifieke kritische drempelwaarde werd bepaald zodanig dat voor elk meetpunt de overschrijding van het aantal droge dagen gemiddeld gelijk is (namelijk 18 dagen), zal de bijdrage van dit effect aanvankelijk relatief gering zijn.
Alleen meetpunten waarbij de grondwaterpeilen geen trend vertonen (cf. verdroging of vernatting) werden geselecteerd.
Daarom kunnen we ook aannemen dat, minstens voor de referentieperiode, de locatie-effecten stabiel in de tijd zullen zijn.

$\epsilon_{jm}$ is de term voor de random ruis in de log-schaal.
$$\epsilon_{jm} \sim N(0,\sigma_{jm}^2) $$
Voor het bepalen van de onzekerheid, de betrouwbaarheidsintervallen, van de trendwaarden doen we opnieuw een beroep op de formule van Rubin [@RN6220].

$${\textstyle {de trend van de droogte-indicator berekend voor Ã©Ã©n jaar : }} \overline{{\textstyle {droogte-ind}}}_{j} =  \sum_{s = 1}^{20}(\overline{{\textstyle {droogte-ind-sim}}}_{j;s} / 20 $$



$$ \bar\sigma^2_{\overline{{\textstyle {droogte-ind}}}_{j}} = \frac{\sum_{s = 1}^{20}\widehat{\sigma}^2_{\overline{{\textstyle {droogte-ind-sim}}}_{j;s}}}{20} + (1 + 1/20)*\frac{\sum_{s=1}^{20}(\overline{{\textstyle {droogte-ind-sim}}}_{j;s} - \overline{{\textstyle {droogte-ind}}}_{j})^2}{(20 - 1)}$$

De ondergrens van het betrouwbaarheidsinterval (LCL) voor een bepaald jaar $j$ wordt dan :

$$ {\textstyle {LCL}}_j = \overline{{\textstyle {droogte-ind}}}_{j} - 1.96 * \sqrt{\bar\sigma^2_{\overline{{\textstyle {droogte-ind}}}_{j}}}$$

De bovengrens van het betrouwbaarheidsinterval (UCL) voor een bepaald jaar $j$ wordt dan :

$$ {\textstyle {UCL}}_j = \overline{{\textstyle {droogte-ind}}}_{j} + 1.96 * \sqrt{\bar\sigma^2_{\overline{{\textstyle {droogte-ind}}}_{j}}}$$


Het berekenen van de droogte-indicator en de betrouwbaarheid en trend ervan werden uitgevoerd met R versie 4.0.2 [@RN6222] en met het softwarepakket INLA [@RN6223].


<!--chapter:end:02_Methode.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Berekening droogte-indicator, betrouwbaarheid en trend {#h4:berekening}

We verkiezen een absolute indicator als droogte-indicator.
Bij een dergelijke indicator wordt het aantal dagen per jaar dat het grondwaterpeil gelijk aan of onder een kritische drempelwaarde zakt opgeteld.
Deze kritische drempelwaarde is specifiek voor elk meetpunt.
Als kritische drempelwaarde wordt gekozen voor 
**het _jaargemiddelde_ van de 5%-percentiel van de grondwatermetingen _van een jaar_ voor het meetpunt voor de periode 1985 - 2014**, cfr. \@ref(h3-2:drempelwaarde), die periodiek, bijv. elke vijftien jaar, met meer recente data kan herijkt worden, cfr. \@ref(h2-2-1:referentietoestand).

## Voorbereiding {#h4-1:voorbereiding}

Tot op heden kon met het software-programma Menyanthes voor 58 meetpunten een tijdreeksmodel gemaakt worden, waarbij 

- neerslag en potentiÃ«le evapotranspiratie voor minstens 66% van de waargenomen variatie kon verklaren en
- er geen significante trend in de tijdreeks kon gedetecteerd worden.

Met deze modellen werden 20 tijdreeksen van dagelijkse grondwaterpeilen gesimuleerd voor de periode 1985 - 2019.
Deze data werden in een centrale databank opgeslagen om daarna te worden ingelezen in R. 
De hierop volgende analysen gebeurden volledig in R.

```{r functies}
#grafiek voor het bekijken van de modelfitting. Het plot de gemeten data (in werkelijkheid omvatten ze zowel geÃ¯mputeerde data als veldmetingen) en de gefitte waarden incl credible interval. 

#hulpfunctie voor het maken van minor ticks in de grafieken
insert_minor <- function(major_labs, n_minor) {
  labs <- c( sapply( major_labs, function(x) c(x, rep("", 4) ) ) )
  labs[1:(length(labs) - n_minor)]}

#plot van de modelfitting
plotfitting <- function(indic_basis, respons, gemid, og, bg) {
  og <- enquo(og)
  bg <- enquo(bg)
  PI_data <- indic_basis %>% group_by(jaar) %>% 
    summarise(ymax_data = max(!! bg, na.rm = TRUE), ymin_data = min(!! og, na.rm = TRUE))
  p <- ggplot(data = indic_basis, aes_string(y = respons, x = "jaar"))
  p <- p + xlab("Jaar") + ylab(respons)
  p <- p + theme(text = element_text(size = 15))
  p <- p + geom_point(shape = 16, size = 2, col = "black")
  p <- p + geom_line(aes_string(x = "jaar", y = gemid), size = 1, color = "red")
  p <- p + geom_ribbon(data = PI_data,
                       aes(x = jaar, ymax = ymax_data, ymin = ymin_data), inherit.aes = F,
                       fill = grey(0.5),
                       alpha = 0.4)
  p <- p + scale_x_continuous(breaks = 1985:2020, 
                              labels = insert_minor(seq(1985, 2020, by = 5), 4))
  p <- p + theme(strip.text = element_text(size = 15))
  return(p)
}

#plot van de trend (zowel modelschatting als berekende)
plottrend <- function(indic_finaal, trend_berekend, intercept) {
  p <- ggplot(data = indic_finaal) + 
    geom_line(aes(x = jaar, y = og_jaar), linetype = "longdash") +
    geom_ribbon(aes(x = jaar, ymax = bg_jaar, ymin = og_jaar),
                fill = grey(0.5),
                alpha = 0.4) +  
    geom_line(aes(x = jaar, y = bg_jaar), linetype = "longdash") +
    geom_line(aes(x = jaar, y = gem_jaar), color = "dark blue") +
    geom_line(aes_string(x = "jaar", y = trend_berekend), color = "red") +
    # geom_point(data = indic_cum_basis, aes(x = jaar, y = lengte_onder_p01)) +
    geom_hline(aes(yintercept = intercept), linetype = "dotted") +
    scale_x_continuous(breaks = 1985:2020, labels = insert_minor(seq(1985, 2020, by = 5), 4)) +
    labs(x = "Jaar", y = "trend")
  return(p)
}

```


<!-- ### Inlezen van ruwe gegevens van de SQL-server {#h4-1-1:ruwedata} -->

```{r inlezen-ruwe-data-sqlserver, eval=FALSE}
# De ruwe data staan op de SQL-server in de FlaVen-databank.
# Het inlezen vergt een betrouwbare (langdurig werkzame) VPN-verbinding en vraagt ook veel tijd.
# Daarom werden de data na het inlezen omgezet in het VC-formaat en lokaal/in github bewaard.
# Het inlezen van deze bestanden gaat 3x-sneller dan het inlezen van de SQL-server.
# de brondata bestaat uit een reeks van 19 tabellen. Door deze op de SQL-server samen te voegen tot Ã©Ã©n bestand, zou het importeren falen.
# het rechtstreeks aanspreken van de SQL-server is een tijdrovend proces en het vraagt ook een stabiele verbinding, wat met een VPN-verbinding niet echt gegarandeerd is.
# Daarom werden de data na het inlezen lokaal weggeschreven in het vc-formaat mbv het git2rdata-package

con <- dbConnect(odbc::odbc(), .connection_string = "Driver=SQL Server;Server=inbo-sql07-prd.inbo.be,1433;Database=D0136_00_Flaven;Trusted_Connection=Yes;")



ruwetabellen_lijst <- data.frame (a = "droogte_tijdreeks", b = "ruwedata", c = seq(from = 1, to = 23))

ruwetabellen_lijst <- ruwetabellen_lijst %>% mutate (naambrontabel = paste0(a,c), 
                                                     naamdoeltabel = sprintf(paste0(b,"%02d"), c)) 

ruwetabellen_lijst <- setNames(ruwetabellen_lijst %>% dplyr::pull(naambrontabel), make.names(ruwetabellen_lijst %>% dplyr::pull(naamdoeltabel)))


list2env(
  lapply(ruwetabellen_lijst, 
         dbReadTable, conn = con,
         guess_max = 300000), 
  envir = .GlobalEnv)

DBI::dbDisconnect(con)


```

```{r wegschrijven-brontabellen-naar-vc-formaat, eval=FALSE }
for (i in seq(from = 1, to = 19)){
  write_vc(get(sprintf("ruwedata%02d", i)), file.path("data", "local", sprintf("ruwedata%02d", i)), sorting = c("dag","meetpunt_import"), strict= FALSE)
}

```


```{r inlezen-vc-tabellen, include=FALSE}
# De data worden niet in Ã©Ã©n keer ingelezen.
# De brondata zitten in 23 bestanden.
# Elk van deze 23 bestanden is op zich al vrij omvangrijk.
# Ze samenvoegen tot Ã©Ã©n bestand, zou kunnen leiden tot importproblemen.
# De opdeling is ook wel praktisch als je met de data iets wil testen.

ruwetabellen_lijst <- data.frame(bron = "ruwedata", doel = "ruwedata", c = seq(from = 1, to = 23))

ruwetabellen_lijst <- ruwetabellen_lijst %>% mutate (naambrontabel = file.path("data", "local", paste0(bron,sprintf("%02d", c))), 
                                                     naamdoeltabel = sprintf(paste0(doel,"%02d"), c)) 

ruwetabellen_lijst <- setNames(ruwetabellen_lijst %>% dplyr::pull(naambrontabel), make.names(ruwetabellen_lijst %>% dplyr::pull(naamdoeltabel)))

list2env(
  lapply(ruwetabellen_lijst, 
         read_vc), 
  envir = .GlobalEnv)

```

```{r samenvoegen-bestanden, include=FALSE}
#ik verkies dit in een aparte chunk te doen, omdat het zo mogelijk is om testdata samen te stellen, bijv. ik heb voor het uittesten van de methoden gewerkt met een testbestand van de eerste 5 ruwe tabellen.
for (i in seq (from = 1, to = 23)){
  if (i == 1) {
    ruwedata <- get(sprintf("ruwedata%02d",i))
  } else {
    ruwedata <- bind_rows(ruwedata, get(sprintf("ruwedata%02d",i)))
  }
}

#data cleaning - algemeen
# 1) uitsluiten van niet gesimuleerde meetreeksen (veldmetingen zitten namelijk al in de simuleerde reeksen, zou dus tot dubbeltellingen leiden) 
# 2) factoriseren van meetpunt en weglaten van ongebruikte velden 

ruwedata <-  ruwedata %>% 
  filter(meetpunt_import != meetreeks, year(dag) >= 1985) %>%  # 
  mutate(meetpunt = factor(meetpunt)) %>% 
  dplyr::select(-meetpunt_import, -meetreeks, -is_veldmeting) #om de grootte van het databestand te reduceren

#data-cleaning - specifiek voor de eerste dataset
#1) jaar 2019 is onvolledig: slechts data tot half mei

ruwedata <- ruwedata %>% 
  filter( year(dag) < 2019)
# indic_abs_basis_gw <- indic_abs_basis_gw %>% 
#   filter( between(simulatienr, 1,20), jaar < 2019)
```

```{r samenvoegen-bestanden-test, include=FALSE}
#ik verkies dit in een aparte chunk te doen, omdat het zo mogelijk is om testdata samen te stellen, bijv. ik heb voor het uittesten van de methoden gewerkt met een testbestand van de eerste 5 ruwe tabellen.
for (i in seq (from = 1, to = 5)){
  if (i == 1) {
    ruwetest <- get(sprintf("ruwedata%02d",i))
  } else {
    ruwetest <- bind_rows(ruwetest, get(sprintf("ruwedata%02d",i)))
  }
}

#data cleaning
ruwetest <-  ruwetest %>% 
  filter(meetpunt_import != meetreeks, year(dag) >= 1985) %>%  #uitsluiten van niet gesimuleerde meetreeksen (veldmetingen zitten namelijk al in de simuleerde reeksen, zou dus tot dubbeltellingen leiden)  
  mutate(meetpunt = factor(meetpunt)) %>% 
  dplyr::select(-meetpunt_import, -meetreeks, -is_veldmeting) #om de grootte van het databestand te reduceren

ruwetest <- ruwetest %>% 
  filter( year(dag) < 2019)
```

```{r verwijderen-tsv-tabellen, eval = FALSE}
#verwijderen van de 23 deelbestanden (beter nog niet doen als je wil testen, het is handig om te testen met Ã©Ã©n van de bestanden, bijv. ruwedata01 (rel. groot) of ruwedata19 (rel klein)
rm(list = sprintf("ruwedata%02d", seq(from = 1, to = 23)))

```

```{r tubes-network, include=FALSE}
#laatste versie met de geselecteerde meetpunten ophalen. De ruwe data bevatten namelijk ook nog meetreeksen van punten van een eerdere versie.
gitroot <- rprojroot::find_root(rprojroot::is_git_root)
tubes_selected <- read_vc(file.path(".","data","result","meetnet","tubes_selected"), root = gitroot)

tubes_indicator <- tubes_selected %>% 
  filter(selectie == 1) %>% 
  dplyr::select(loc_code, groupnr)

#beperken van de ruwe data tot de laatste versie van de geselecteerde meetpunten
ruwedata <- ruwedata %>% 
  semi_join(tubes_indicator, by = c("meetpunt" = "loc_code"))

# #linken van de metingen aan een gw-groep, cfr. MNM
# tubes_in_raster <- read_vc(file.path(".","data","processed","meetnet","tubes_in_raster"), root = gitroot)
# tubes_gw <- tubes_in_raster %>% 
#   dplyr::select(loc_code, groupnr)
# ruwedata <- ruwedata %>% 
#   left_join(tubes_gw, by = c("meetpunt" = "loc_code")) #left_join om te testen


```

### Berekenen kritische drempelwaarden {#h4-1-1:drempelwaarde}
Een absolute indicator vergelijkt dagelijks het grondwaterpeil met een kritische drempelwaarde. 
De dagen dat het grondwaterpeil onder deze drempelwaarde valt, worden per jaar opgeteld (\@ref(h3-2:drempelwaarde) en \@ref(h3-3:indicator)).

```{r absolute-drempelwaarden-schrikkeljaren, include=FALSE}
absperc <- ruwedata %>% 
  mutate(jaar = year(dag)) %>% 
  filter(dplyr::between(jaar,1985,2014)) %>% 
  group_by(meetpunt, jaar) %>% 
  summarise(p01 = quantile(meting_TAW, 1/100),
            p05 = quantile(meting_TAW, 5/100),
            p10 = quantile(meting_TAW, 10/100),
            p30 = quantile(meting_TAW, 30/100),
            p50 = quantile(meting_TAW, 50/100),
            p70 = quantile(meting_TAW, 70/100),
            p90 = quantile(meting_TAW, 90/100),
            p95 = quantile(meting_TAW, 95/100),
            p99 = quantile(meting_TAW, 99/100)
            ) %>% 
  group_by(meetpunt) %>% 
  summarise(p01 = mean(p01),
            p05 = mean(p05),
            p10 = mean(p10),
            p30 = mean(p30),
            p50 = mean(p50),
            p70 = mean(p70),
            p90 = mean(p90),
            p95 = mean(p95),
            p99 = mean(p99)
            ) %>%   
  ungroup()


schrikkeljaar <- ruwedata %>% 
  mutate(jaar = year(dag)) %>%   
  filter(meetpunt == 
           ruwedata %>% 
           dplyr::select(meetpunt) %>% 
           head(1) %>% 
           dplyr::pull(meetpunt)
         ) %>% 
  filter(day(dag) == 29, month(dag) == 2) %>% 
  distinct(jaar) %>% 
  arrange(jaar) %>% 
  dplyr::pull(jaar)


#vrijmaken geheugenruimte, kan soms van pas komen
  gc()
```
```{r gwgroups, include=FALSE}
#herijking grondwatertype-groepen, want er blijkt nog nauwelijks een verband te bestaan tussen de amplitude van een pb en de gw-typegroep waartoe het wordt gerekend
absperc_gw <- absperc %>% 
  inner_join(tubes_indicator %>% 
               mutate(groep3 = ifelse(groupnr == 1, 2, groupnr)) %>% 
               dplyr::select(-groupnr), by = c("meetpunt" = "loc_code")) %>% 
  mutate(ampl = p99 - p01,
         groep3n = case_when(
           ampl < 0.25 ~2,
           ampl < 0.4 ~3,
           TRUE ~4),
         meetpunt = factor(meetpunt)
         )

write_vc(absperc_gw, file.path("data", "result", "percentielen_1985_2014"), sorting = c("meetpunt"), strict = FALSE)
```

```{r abs-indicator}

dagen_droog <- ruwedata %>% #oude objectnaam: indic_abs_basis
  inner_join(absperc_gw, by = "meetpunt") %>% 
  mutate(jaar = year(dag),
         aantaldagen_jaar = if_else(jaar %in% schrikkeljaar, 366, 365 )
         ) %>% 
  mutate( 
          dag_onder_p01 = if_else(meting_TAW < p01,1,0),
          dag_onder_p05 = if_else(meting_TAW < p05,1,0),
          dag_onder_p10 = if_else(meting_TAW < p10,1,0),
          dag_onder_p30 = if_else(meting_TAW < p30,1,0),
          dag_boven_p01 = if_else(dag_onder_p01 == 0,1,0),
          dag_boven_p05 = if_else(dag_onder_p05 == 0,1,0),
          dag_boven_p10 = if_else(dag_onder_p10 == 0,1,0),
          dag_boven_p30 = if_else(dag_onder_p30 == 0,1,0)          
  ) %>% 
  group_by(meetpunt, simulatienr,jaar, aantaldagen_jaar, groep3, groep3n) %>% 
  summarise_at(vars(dag_onder_p01:dag_boven_p30), sum) %>% 
  ungroup() %>% 
  mutate(jaar_factor = factor(jaar)
  )

# #met opgave gw-groep
# indic_abs_basis_gw <- ruwedata %>% 
#   inner_join(absperc_gw, by = "meetpunt") %>% 
#   mutate(jaar = year(dag),
#          meetpunt = factor(meetpunt),
#          aantaldagen_jaar = if_else(jaar %in% schrikkeljaar, 366, 365 )
#   ) %>% 
#   mutate( 
#     dag_onder_p01 = if_else(meting_TAW < p01,1,0),
#     dag_onder_p05 = if_else(meting_TAW < p05,1,0),
#     dag_onder_p10 = if_else(meting_TAW < p10,1,0),
#     dag_onder_p30 = if_else(meting_TAW < p30,1,0),
#     dag_boven_p01 = if_else(dag_onder_p01 == 0,1,0),
#     dag_boven_p05 = if_else(dag_onder_p05 == 0,1,0),
#     dag_boven_p10 = if_else(dag_onder_p10 == 0,1,0),
#     dag_boven_p30 = if_else(dag_onder_p30 == 0,1,0)          
#   ) %>% 
#   group_by(groep3n, meetpunt, simulatienr,jaar, aantaldagen_jaar) %>% 
#   summarise_at(vars(dag_onder_p01:dag_boven_p30), sum) %>% 
#   ungroup() %>% 
#   mutate(jaar_factor = factor(jaar)
#   )


```
### Verdeling van de indicator {#h4-1-2:verdeling-indicator}

De techniek die we wensen toe te passen bij de modelbouw is parametrisch: ze vereist dat er assumpties gemaakt worden over de verdeling van de afhankelijke variabele.

We beschikken voor elk jaar en meetpunt over twintig simulaties.
Dit laat in zekere mate toe de verdeling ervan te bestuderen.

In theorie is de indicator te beschouwen als een discrete variabele. 
Het feit dat er een kritische drempelwaarde is die al dan niet overschreden wordt en het aantal dagen van een jaar (= aantal 'pogingen') vast ligt, wijzen in de richting van een binomiale verdeling met n = 365 of 366 en p = 0.05.

De p-waarde ligt echter niet vast.
De kritische drempelwaarde werd immers bepaald op basis van een gemiddelde over 30 jaar. 
In droge jaren zal de kans p dat deze zal overschreden worden, veel groter zijn dan in natte jaren.
In dat geval is een negatief binominale verdeling meer aangewezen.

Een groter probleem is dat Ã©Ã©n belangrijke conditie voor een verdeling wordt geschonden. 
De 'trekkingen' gebeuren namelijk niet onafhankelijk van elkaar: de kans dat als het vandaag een droge dag is, het dat morgen of overmorgen ook zal zijn is veel groter dan 0.05 en vice versa. 

Daarom werd de verdeling van de indicator niet alleen vergeleken met de negatief-binominale, maar ook met de poisson- en de binominale verdeling. 

Voor deze vergelijking werd gebruikt gemaakt van zogenaamde QQ-plots. 
Een QQ-plot zet de kans uit dat een bepaalde waarde of kleiner uit een bepaalde verdeling wordt getrokken uit ten opzichte van de percentielwaarde van deze waarde.

De verdelingen werden steekproefgewijs getest op een aantal meetpunten en jaren. 
Deze testen gaven aan dat de verdeling vrij goed overeenkwam met de binomiale of negatief binomiale verdeling. 
De overeenkomst met de poisson-verdeling was meestal relatief iets minder goed.

```{r check-distribution-qq}

checkdistributie <- dagen_droog %>% 
                                 filter(jaar == 2006, meetpunt == "ASBP003") %>% #ALMP003 ASBP003 BTRP001 COOP001 DYLP029 GSCP017
        dplyr::pull(dag_onder_p05)

```

De figuren \@ref(fig:check-qq-poisson), \@ref(fig:check-qq-nbinom) en \@ref(fig:check-distribution-qq-binom) geven een voorbeeld van een QQ-plot voor resp. de poisson, de negatief-binomiale en binomiale verdeling.

```{r check-qq-poisson, fig.cap = "QQ-plot poisson-verdeling"}

poisson <- MASS::fitdistr(checkdistributie, "Poisson")
car::qqp(checkdistributie, "pois", lambda = poisson$estimate, id = FALSE)

```

```{r check-qq-nbinom, fig.cap = "QQ-plot negatief binomiale-verdeling"}

nbinom <- MASS::fitdistr(checkdistributie, "Negative Binomial")
qqPlot(checkdistributie, "nbinom", size = nbinom$estimate[[1]], mu = nbinom$estimate[[2]], id = FALSE)

```

```{r check-distribution-qq-binom, fig.cap = "QQ-plot binomiale-verdeling"}
binom <- fitdistrplus::fitdist(checkdistributie, "binom", fix.arg = list(size = 365), start = list(prob = 0.1))
#summary(binom)
qqp(checkdistributie, "binom", size = 365, prob = binom$estimate, id = FALSE)

```


```{r check-distribution boxplot, eval = FALSE}
boxplot(checkdistributie/365)

#ggplot(data = checkdistributie, aes(dag_onder_p01)) + geom_histogram() 
#ggplot(data = data.frame(checkdistributie), aes(dag_onder_p05)) + geom_histogram() 
#ggplot(data = checkdistributie, aes(dag_onder_p10)) + geom_histogram()  
#ggplot(data = checkdistributie, aes(dag_onder_p30)) + geom_histogram()
```


```{r}
check <- dagen_droog %>% 
  group_by(meetpunt) %>% 
  count()
```

## Berekening van de droogte-indicator en haar betrouwbaarheid {#h4-2:droogte-indicator}

### Droogte-indicator {#h4-2-1:droogte-indicator}
De droogte-indicator is op zich vrij eenvoudig te berekenen door voor elk jaar het gemiddelde te berekenen van de ${\text {dagen_droog}}$-waarden, cfr. \@ref(h3-3:indicator).


Tabel \@ref(fig:droogte-indicator) geeft de berekende indicator-waarden.


```{r droogte-indicator, include = TRUE, fig.cap="Droogte-indicator 1985 - 2018"}
droogte_ind_j <- dagen_droog %>% 
  group_by(jaar) %>% 
  summarise(droogte_ind_j = mean(dag_onder_p05)
            ) %>% 
  ungroup()

DT::datatable(
  droogte_ind_j %>% 
    rename (indicator = droogte_ind_j),
  caption = "Droogte-indicator 1985 - 2018",
  width = 600
  ) %>% 
  DT::formatRound(columns = 2,
                  digits = 1)

```


Figuur \@ref(fig:droogte-indicator-figuur) is hiervan een grafische weergave.
De groene lijn in de figuur geeft het aantal dagen dat jaarlijks gemiddeld verwacht wordt.
Voor een toelichting van de figuur zie verder (\@ref(h4-2-2:betrouwbaarheid)).

```{r droogte-indicator-figuur, fig.cap= "Droogte-indicator 1985 - 2018"}
g <- ggplot(data = droogte_ind_j, aes(x = jaar, y = droogte_ind_j)) + 
  geom_area() + theme_inbo() +
  geom_point(color = "red", shape = "cross") +
  geom_hline(yintercept = 365*0.05, color = "green", linetype = "dashed") +
  labs (y = "aantal droge dagen") + 
  scale_x_continuous(n.breaks = nrow(droogte_ind_j)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
g
```
### Betrouwbaarheid {#h4-2-2:betrouwbaarheid}

We wensen ook inzicht te krijgen in de onzekerheid die er op de droogte-indicator zit, m.a.w. wat is het betrouwbaarheidsinterval van de droogte-indicator.
We doen hiervoor beroep op de formule van Rubin (\@ref(h3-3:indicator)). 
Deze formule laat toe de onzekerheid die inherent is aan de data (verschillen tussen de locaties) te scheiden van de onzekerheid door het ontbreken van gegevens.

```{r droogte-indicator-met-ci, include=FALSE}
droogte_ind_j_s <- dagen_droog %>% 
  group_by(jaar, simulatienr) %>% 
  summarise(droogte_ind_j_s = mean(dag_onder_p05),
            aantal = n(),
            dagen_droog_se = sd(dag_onder_p05)/sqrt(aantal)
            ) %>% 
  ungroup()

droogte_ind_j_var <- droogte_ind_j_s %>% 
  inner_join(droogte_ind_j) %>% 
  group_by(jaar) %>% 
  summarise(dagen_droog_gem_var = mean(dagen_droog_se^2),
            aantalsim= n(),
            imput_var = (1+1/aantalsim) * sum((droogte_ind_j_s - droogte_ind_j)^2/(aantalsim-1)),
            droogte_ind_j_var = dagen_droog_gem_var + imput_var
            ) %>% 
  ungroup() %>% 
  dplyr::select (-aantalsim)

droogte_ind_j_var <- droogte_ind_j_var %>% 
  mutate (rel_bijdrage_imput = round(imput_var/droogte_ind_j_var*100,0))


droogte_ind_j <- droogte_ind_j %>% 
  inner_join(droogte_ind_j_var %>% 
               dplyr::select(-starts_with(c("dagen", "imput", "rel")))) %>% 
  mutate(lcl = droogte_ind_j - 1.96*sqrt(droogte_ind_j_var),
         ucl = droogte_ind_j + 1.96*sqrt(droogte_ind_j_var)
         )

```

```{r droogte-indicator-met-ci-vc, include=FALSE}
write_vc(droogte_ind_j, file.path("data", "result", "droogte-indicator"), sorting = c("jaar"), strict= FALSE)
```

Tabel \@ref(fig:droogte-indicator-ci-tbl) geeft de berekende indicator-waarden inclusief het 95% betrouwbaarheidsinterval (CI).

```{r droogte-indicator-ci-tbl, include = TRUE, fig.cap="Droogte-indicator inclusief 95% betrouwhaarheidsinterval 1985 - 2018"}

DT::datatable(
  droogte_ind_j %>% 
    dplyr::select(-droogte_ind_j_var) %>% 
    rename ('ondergrens (95% CI)' = lcl,
            'bovengrens (95% CI)' = ucl,
            indicator = droogte_ind_j
            ),
  caption = "Droogte-indicator inclusief 95% betrouwhaarheidsinterval (CI) 1985 - 2018"
  ) %>% 
  DT::formatRound(columns = 2:4,
                  digits = 1)

```



Figuur \@ref(fig:droogte-indicator-met-ci-figuur) is hiervan een grafische weergave.
De groene lijn in de figuur geeft het aantal dagen dat jaarlijks gemiddeld verwacht wordt.

Het grillige patroon van de indicator springt hierbij in het oog.
Een 'normaal' jaar is eerder uitzondering dan regel.
Als het droog is, is het ook vaak flink droog. 
Natte jaren zijn minder opvallend, omdat de droogte-indicator niet onder nul kan gaan.
Uitgezonderd voor het jaar 2018 zit er vrij weinig variatie in de hoogte van de pieken. 
Men ziet wel een wijziging in de frequentie ervan, met een toename vanaf rond 2000.
Dit wordt verder onderzocht in het onderzoek van de trend.

```{r droogte-indicator-met-ci-figuur, fig.cap= "Droogte-indicator"}
g <- ggplot(data = droogte_ind_j, aes(x = jaar, y = droogte_ind_j)) + 
  theme_inbo() +
  geom_ribbon(aes(ymin = lcl, ymax = ucl)) +
  geom_hline(yintercept = 365*0.05, color = "green", linetype = "dashed") +
  geom_line(color = "red", size = 0.5) + 
  labs (y = "droogte-indicator") + 
  scale_x_continuous(n.breaks = nrow(droogte_ind_j)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
g
```

De formule van Rubin laat toe om in te schatten wat de kost is van het ontbreken van data op de betrouwbaarheid van het resultaat.
Onderstaande figuur (\@ref(fig:droogte-indicator-imput-fig)) toont het aandeel in de totale variatie ten gevolge van het schatten van ontbrekende gegevens. 
Dit is meestal meer dan 10% en kan tot 50% bedragen.
Er zit een duidelijke neerwaartse trend in.
Deze trend is te verklaren door de toegenomen meetintensiteit.

```{r droogte-indicator-imput-fig, fig.cap="het aandeel van imputatie in de totale variatie", message=FALSE}
g <- ggplot(data = droogte_ind_j_var, aes(x = jaar, y= rel_bijdrage_imput)) + 
  geom_line() + geom_smooth() + theme_inbo() +
  labs (y = "aandeel (%)") + 
  scale_x_continuous(n.breaks = nrow(droogte_ind_j)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
g
```

## Berekening van de trend in de droogte-indicator {#h4-3:trend}

Bij een indicator is het verloop van de waarden nog belangrijker dan de absolute waarden an sich.
Zijn in onze de natuurgebieden de grondwaterpeilen ten gevolge van neerslagtekort aan het dalen ?
Om dit te kunnen nagaan stellen we een model op dat de variatie in de indicatorwaarden tracht te verklaren. 
In het model is de factor tijd Ã©Ã©n van de verklarende variabelen.
De andere verklarende factor is de locatie (de ene plaats kan een afwijkend gedrag vertonen dan een andere).
We onderzoeken hier alleen het tijdsaspect. 
Een mogelijke andere interessante vraag is of er regionale verschillen zijn tussen de waarden en waardoor deze dan  kunnen verklaard worden. 
Deze vragen blijven momenteel nog onbeantwoord.

Voor de berekening van de trend doen we beroep op Bayesiaanse modeltechnieken.
Deze technieken laten toe om voorkennis over de data te gebruiken bij het modelleren. 
We passen dit principe toe bij de vorm van de curve die we aan de trendlijn willen geven.
Een model dat heel goed de data kan voorspellen zal ongeveer het grillige patroon volgen van de indicator. 
We hebben dan wel een heel goed model, alleen bekomen we zo weinig extra informatie of er nu een geleidelijke verandering aan de gang is.
Door uit te gaan of op te leggen dat de curve elk jaar niet veel mag veranderen, kunnen we de curve minder grillig laten zijn. 

Het instellen van deze 'smoothing' = het meer of minder grillig laten zijn van de trendlijn is een subjectief gegeven en steunt ook op trial en error van de keuze van de smoothing-parameters.  
De trendlijn is daarom te interpreteren als 'stel dat de toe- of afname (min of meer) rechtlijnig zou zijn, hoe zou die trendlijn er dan uitzien'.

```{r abs-indic-model-function-exploratory, eval=FALSE}
indic_abs_function <- function(modeldata, suffix= "", respons, percentile, indicatorname, standardised) {

  #instellen van de priors. Dit is 
  #prec.prior <- list(prec = list(param = c(0.001, 0.001)))
  
  #De instelling van de prior heeft een doorslaggevend effect op de vorm van de trendlijn. 
  #Geven we het model de vrijheid om een trendlijn te bepalen dan voegen we weinig apriori-kennis toe aan het model
  #Voor de random-walk van de tweede orde doen we dat via de prior voor de precisie. Deze bevat twee elementen: de standaarddeviatie en een alfa. Het eerste element geeft aan in welke mate we denken/willen dat de rw2 mag fluctueren en en de alfa de zekerheid die we daarover hebben. Wil je een quasi rechte lijn, dan moeten beide parameters klein ingesteld worden. Laat je ze vrij, dan kan de trend een grillig patroon gaan vertonen.
  prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.025, 0.001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.25, 0.001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.25, 0.95)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(2.5, 0.95)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(2.5, 0.001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.0025, 0.001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.0025, 0.99)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  # prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.0025, 0.0001)))# list(theta = list(prec = list(param = c(0.001, 0.001))))  
  prec.prior.mp <- list(theta = list(prior = "pc.prec", param = c(0.025, 0.95)))# list(theta = list(prec = list(param = c(0.001, 0.001)))) 
  model <- as.formula(paste(respons, "~", "f(jaar, model =", "'rw2', scale.model = TRUE,
                          hyper = prec.prior)+ f(meetpunt, model = 'iid', hyper = prec.prior.mp)", sep = " "))   
  # model <- as.formula(paste(respons, "~", "1 + jaar_factor + f(meetpunt, model = 'iid', hyper = prec.prior)", sep = " "))     
  suffix <- ifelse(suffix == "", "", paste0("_", suffix))
  resultname_stat <- paste0("indic_abs_p", percentile, suffix, "_jaar_stat", if (standardised == TRUE) ("_std"))
  resultname_fitted <- paste0("indic_abs_p", percentile, suffix, "_fitted", if (standardised == TRUE) ("_std"))
  if (percentile == "01") {
    reeks <- c(1:20) #1 model wou maar niet convergeren
  } else {
    reeks <- c(1:20)    
  }  
  teller <- 0
  for (i in reeks) {
    #i = 16
    mdata <- modeldata[modeldata$simulatienr == i,]
    jaren <- mdata %>% distinct(jaar) %>% mutate(simulatienr = i)
    
    #samenstellen van een tweeledig dataframe. De eerste 34 rijen (#jaren) zijn leeg en dienen om de gemiddelde waarden en de bijhorende fouten te berekenen. Het tweede deel dient om het model mee te bouwen
    mdata <- bind_rows(jaren, mdata)    
    # mdata[mdata[,respons] == 0,respons] <- 1e16
    print(i)    
    teller <- teller + 1
    I2 <- inla(model, 
                     control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
                     family = modelkeuze %>% filter(percentiel == percentile) %>% 
                              dplyr::pull(model), 
                     #Ntrials = aantaldagen_jaar,
                     data = mdata
    )

    # I2b <- inla(model,
    #            control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
    #            family = "nbinomial",
    #            #Ntrials = aantaldagen_jaar,
    #            data = mdata
    # )
    # I2c <- inla(model,
    #             control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
    #             family = "zeroinflatednbinomial1",
    #             #Ntrials = aantaldagen_jaar,
    #             data = mdata,
    #             verbose = FALSE
    # )
    # I2d <- inla(model,
    #             control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
    #             family = "zeroinflatednbinomial0",
    #             #Ntrials = aantaldagen_jaar,
    #             data = mdata
    # )
    # de negatieve binomiale modellen gebruiken de logit-link
    #om de niet-getransformeerde waarden te krijgen moet men zowel de intercept als de coÃ«fficiÃ«nten exponentiÃ«ren. Exp(standaardfout) heeft geen zin, maar het was moeilijker om deze uit te sluiten dan ze (verkeerdelijk) mee te nemen
    #summary(I2)
    # result_stat_i <-  I2$summary.random$jaar %>%
    #   mutate_at(names(I2$summary.random$jaar)[2:6], exp) %>%
    #   mutate_at(names(I2$summary.random$jaar)[2:6], function(x){x*exp(I2$summary.fixed$mean)}) %>%       mutate(simulatienr = i) %>%
    #   dplyr::select(-sd, -mode, -kld)
    
    #linear_predictor : deze is niet teruggetransformeteerd. We zijn hier alleen geÃ¯nteresseerd in de rijen met lege responsen: hier krijg je dan per jaar een gemiddelde predictie Ã©n de se.
    result_stat_i <- I2$summary.linear.predictor %>% 
      slice(1:nrow(jaren)) %>% 
      bind_cols(jaren) %>% 
      mutate(intercept = I2$summary.fixed$mean) %>% 
      dplyr::select(-mode, -kld)    
    #summary(I2b)  
    #modelkeuze %>% filter(percentiel == percentile) %>% dplyr::pull(model)

    # sum(log(I2$cpo$cpo))
    # sum(log(I2b$cpo$cpo))
    # sum(log(I2c$cpo$cpo))
    # sum(log(I2d$cpo$cpo))
    # # sum(log(I2_binom$cpo$cpo))
    # 
    # sum(log(I2$dic$dic))
    # sum(log(I2b$dic$dic))
    # sum(log(I2c$dic$dic))
    # sum(log(I2d$dic$dic))
    # 
    # sum(log(I2$waic$waic))
    # sum(log(I2b$waic$waic))
    # sum(log(I2c$waic$waic))
    # sum(log(I2d$waic$waic))
    # 
    # sum(I2$mlik)
    # sum(I2b$mlik)
    # sum(I2c$mlik)
    # sum(I2d$mlik)

    # names(inla.models()$likelihood)
    
    # # Assess overdispersion (variantie / aantal vrijheidsgraden ~ 1)
     # #voor binomiaal
     # Pi   <- I2b$summary.fitted.values[,"mean"]
     # ExpY <- Pi * mdata$aantaldagen_jaar
     # VarY <- Pi * mdata$aantaldagen_jaar * (1 - Pi)
     # E1   <- (mdata %>%
     #               dplyr::pull(!!indicatorname) - ExpY) / sqrt(VarY)
     # N    <- nrow(mdata)
     # p <- nrow(I2b$summary.fixed)
     # Dispersion <- sum(E1^2) / (N - p)
     # Dispersion
    
    # #voor poisson
    # Pi   <- I2c$summary.fitted.values[,"mean"]
    # ExpY <- Pi #* mdata$aantaldagen_jaar
    # VarY <- Pi #* mdata$aantaldagen_jaar * (1 - Pi)
    # E1   <- (mdata %>%
    #               dplyr::pull(!!indicatorname) - Pi) / sqrt(VarY)
    # N    <- nrow(mdata)
    # p <- nrow(I2c$summary.fixed)
    # Dispersion <- sum(E1^2) / (N - p)
    # Dispersion
    
    # #voor negatief binomiaal
    # Pi  <- I2$summary.fitted.values[,"mean"] [-(1:nrow(jaren))]
    # theta <- I2$summary.hyperpar[1,"mean"]
    # E1 <- (mdata %>% slice(-(1:nrow(jaren))) %>%
    #          dplyr::pull(!!indicatorname)  - Pi) / sqrt(Pi + Pi^2 / theta)
    # sum(E1^2) / (nrow(mdata) - 1)
    # 
    # Pi  <- I2b$summary.fitted.values[,"mean"]
    # theta <- I2b$summary.hyperpar[1,"mean"]
    # E1 <- (mdata %>% slice(-(1:nrow(jaren))) %>%
    #          dplyr::pull(!!indicatorname)  - Pi) / sqrt(Pi + Pi^2 / theta)
    # sum(E1^2) / (nrow(mdata) - 1)


    # 
    # Pi  <- I2c$summary.fitted.values[,"mean"]
    # theta <- I2c$summary.hyperpar[1,"mean"]
    # E1 <- (mdata %>%
    #          dplyr::pull(!!indicatorname)  - Pi) / sqrt(Pi + Pi^2 / theta)
    # sum(E1^2) / (nrow(mdata) - 1)
    # 
    # 
    # Pi  <- I2d$summary.fitted.values[,"mean"]
    # theta <- I2d$summary.hyperpar[1,"mean"]
    # E1 <- (mdata %>%
    #          dplyr::pull(!!indicatorname)  - Pi) / sqrt(Pi + Pi^2 / theta)
    # sum(E1^2) / (nrow(mdata) - 1)
    # 
    # # Pearson residuals
    # par(mfrow = c(1,1), mar = c(5,5,2,2), cex.lab = 1.5)
    # plot(x = Pi,
    #      y = E1,
    #      xlab = "Fitted values",
    #      ylab = "Pearson residuals")
    # abline(h = 0, lty = 2)
    # 
    # #names(inla.models()$likelihood)
    # 
    # # bekijk de gefitte waarden van het model
    # # Plot the fitted values
    # Fit1     <- I2$summary.fitted.values[,"mean"][-(1:nrow(jaren))]
    # Fit1.025 <- I2$summary.fitted.values$"0.025quant"[-(1:nrow(jaren))]
    # Fit1.975 <- I2$summary.fitted.values$"0.975quant"[-(1:nrow(jaren))]
    # # 
    # # Fit1     <- I2d$summary.fitted.values[,"mean"]
    # # Fit1.025 <- I2d$summary.fitted.values$"0.025quant"
    # # Fit1.975 <- I2d$summary.fitted.values$"0.975quant"
    # # 
    # check <- I2$summary.fitted.values[,"mean"][(1:nrow(jaren))] %>% bind_cols(jaren)
    # check2 <- mdata2 %>%
    #   group_by(jaar) %>%
    #   summarise(gemj = mean(Fitted1))
    # check <- check %>% inner_join(check2, by = "jaar")
    # write_csv(check, "check.csv")
    # result_stat_i2 <- result_stat_i2 %>%
    #   mutate(terug = inla.link.log(mean, inverse = TRUE))
    # #   #
    # # check <- I2$summary.random$meetpunt
    # #
    # # result_fitted_i
    # mdata2 <- mdata %>% slice(-(1:nrow(jaren)))
    # mdata2$Fitted1  <- Fit1
    # mdata2$Fit1.025 <- Fit1.025
    # mdata2$Fit1.975 <- Fit1.975
    # #gdata <- mdata %>% dplyr::select(!!respons, jaar, contains("Fit"))
    # p <- ggplot(data = mdata2, aes_string(y = respons, x = "jaar"))
    # p <- p + xlab("Jaar") + ylab(respons)
    # p <- p + theme(text = element_text(size = 15))
    # p <- p + geom_point(shape = 16, size = 2, col = "black")
    # p <- p + geom_line(aes(x = jaar, y = Fitted1))
    # p <- p + geom_ribbon(data = mdata2 %>% group_by(jaar) %>% summarise(ymax_data = max(Fit1.975), ymin_data = min(Fit1.025)), aes(x = jaar,
    #                          ymax = ymax_data,
    #                          ymin = ymin_data), inherit.aes = F,
    #                      fill = grey(0.5),
    #                      alpha = 0.4)
    # p <- p + theme(strip.text = element_text(size = 15))
    # p
    # summary(I2)
    # result_stat_i <-  I2$summary.random$jaar %>%
    #   mutate(simulatienr = i)
    #  result_stat_i <- result_stat_i %>%  rename (p0.025 = '0.025quant',
    #                              p975.5 = '0.975quant',
    #                              jaar =  ID)
    #  gplot <- ggplot(data = result_stat_i, aes(x = jaar, y = mean)) +
    #    geom_line(aes(x = jaar, y = p0.025), linetype = "longdash") +
    #    geom_ribbon(aes(x = jaar, ymax = p975.5, ymin = p0.025)) +
    #    geom_line(aes(x = jaar, y = p975.5), linetype = "longdash") +
    #    geom_line(color = "lightblue") +
    #    #geom_point(data = mdata, aes_string(x = "jaar", y = respons)) +
    #    geom_hline(aes(yintercept = 0), linetype = "dotted") +
    #    labs(x = "Jaar", y = "trend")
    #  gplot
    # 
    # #conclusie negative binomiaal (bij 30 wel onderdispersed), gestandardiseerd met een gewijzigde non-informatieve prior
    # 
    # result_stat_i_meetpunt <-  I2$summary.random$meetpunt %>% 
    #   mutate(simulatienr = i)
    
    # result_stat_i <- result_stat_i %>% 
    #   mutate(og_berekend = mean - 1.96*sd,
    #          bg_berekend = mean + 1.96*sd)
    
    #gefitte waarden (deze zijn wel teruggetransformeteerd)    
    varname_mean <- paste0("p", percentile, "_mean", if (standardised == TRUE) ("_std"), "_fitted")
    varname_sd <- paste0("p", percentile, "_sd", if (standardised == TRUE) ("_std"), "_fitted")
    varname_p025 <- paste0("p", percentile, "_p02.5", if (standardised == TRUE) ("_std"), "_fitted")
    varname_p975 <- paste0("p", percentile, "_p97.5", if (standardised == TRUE) ("_std"), "_fitted")
    result_fitted_i <-  I2$summary.fitted.values %>% 
      rename(!!varname_mean := mean,
             !!varname_sd := sd,
             !!varname_p025 := '0.025quant',
             !!varname_p975 := '0.975quant')

    mdata <- bind_cols(mdata, result_fitted_i) %>% 
      slice(-(1:nrow(jaren))) #de regels met lege responsen hieruit verwijderen    
    if (standardised == TRUE) {
      varname_mean_backtransformed <- paste0(varname_mean, "_untr")
      varname_p025_backtransformed <- paste0(varname_p025, "_untr")
      varname_p975_backtransformed <- paste0(varname_p975, "_untr")
      result_fitted_i <- result_fitted_i %>% 
        mutate( !!varname_mean_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_mean),m,s),
                !!varname_p025_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_p025),m,s),
                !!varname_p975_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_p975),m,s)    
        )
    }
    if (teller == 1) {
      result_stat <- result_stat_i
      result_fitted <- mdata
      
    } else {
      result_stat <- bind_rows(result_stat, 
                               result_stat_i)
      result_fitted <- bind_rows(result_fitted, mdata)    
    }
    
    if (teller == length(reeks)) {  
      result_stat <- result_stat %>% 
        rename( p02.5 = '0.025quant',
                p50 = '0.5quant',
                p97.5 = '0.975quant')
      
        if (standardised == TRUE) {
          result_stat <- result_stat %>% 
            mutate(mean_untr = unscale(mean, m, s),
                   og_berekend_untr = unscale(og_berekend, m, s),
                   bg_berekend_untr = unscale(bg_berekend, m, s),
                   p02.5_untr = unscale(p02.5, m, s),
                   p97.5_untr = unscale(p97.5, m, s),
                   se_berekend_untr = ((p97.5_untr  - mean_untr )/1.96 - 
                                         (p02.5_untr  - mean_untr )/1.96)/2,
            )
        }
      resultlijst <- list( result_stat, 
                           result_fitted)
      names(resultlijst) <- c(resultname_stat, resultname_fitted)
      list2env(resultlijst, envir = .GlobalEnv)
      
      if (varname_mean %in% colnames(dagen_droog)) {
        dagen_droog <- dagen_droog %>% 
          dplyr::select(-!!varname_mean, -!!varname_sd, -!!varname_p025, -!!varname_p975) 
      }
      
      dagen_droog <- dagen_droog %>% 
         inner_join(result_fitted %>% 
                      dplyr::select(contains("fitted"), 1:3), 
                    by = c("meetpunt","simulatienr", "jaar")) 
    }
  }
  return(dagen_droog)
}

```

```{r abs-indic-model-function-final}
indic_abs_function <- function(modeldata, suffix= "", respons, percentile, indicatorname, standardised) {
  #De instelling van de prior heeft een doorslaggevend effect op de vorm van de trendlijn. 
  #Geven we het model de vrijheid om een trendlijn te bepalen dan voegen we weinig apriori-kennis toe aan het model
  #Voor de random-walk van de tweede orde doen we dat via de prior voor de precisie. Deze bevat twee elementen: de standaarddeviatie en een alfa. Het eerste element geeft aan in welke mate we denken/willen dat de rw2 mag fluctueren en en de alfa de zekerheid die we daarover hebben. Wil je een quasi rechte lijn, dan moeten beide parameters klein ingesteld worden. Laat je ze vrij, dan kan de trend een grillig patroon gaan vertonen.
  
  #voor de trendlijn zijn we vrij streng om een min of meer rechte, zacht glooiende, lijn te krijgen
  prec.prior <- list(theta = list(prior = "pc.prec", param = c(0.025, 0.001)))
  
  #ivm de variatie op de meetpunten brengen we niet veel voorkennis in het model, om deze zoveel mogelijk door het model te laten bepalen
  prec.prior.mp <- list(theta = list(prior = "pc.prec", param = c(0.025, 0.95)))# list(theta = list(prec = list(param = c(0.001, 0.001)))) 
  
  model <- as.formula(paste(respons, "~", "f(jaar, model =", "'rw2', scale.model = TRUE,
                          hyper = prec.prior)+ f(meetpunt, model = 'iid', hyper = prec.prior.mp)", sep = " "))   
       
  suffix <- ifelse(suffix == "", "", paste0("_", suffix))
  resultname_stat <- paste0("indic_abs_p", percentile, suffix, "_jaar_stat", if (standardised == TRUE) ("_std"))
  resultname_fitted <- paste0("indic_abs_p", percentile, suffix, "_fitted", if (standardised == TRUE) ("_std"))
  if (percentile == "01") {
    reeks <- c(1:20) #1 model wou maar niet convergeren
  } else {
    reeks <- c(1:20)    
  }  
  teller <- 0
  for (i in reeks) {
    #i = 16
    
    #samenstellen van een tweeledig dataframe. De eerste 34 rijen (#jaren) zijn leeg en dienen om de gemiddelde waarden en de bijhorende fouten te berekenen. Het tweede deel dient om het model mee te bouwen    
    mdata <- modeldata[modeldata$simulatienr == i,]
    jaren <- mdata %>% distinct(jaar) %>% mutate(simulatienr = i)
    mdata <- bind_rows(jaren, mdata)    

    print(i)    
    teller <- teller + 1
    I2 <- inla(model, 
                     control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
                     family = modelkeuze %>% filter(percentiel == percentile) %>% 
                              dplyr::pull(model), 
                     data = mdata
    )


    #linear_predictor : deze is niet teruggetransformeteerd. We zijn hier alleen geÃ¯nteresseerd in de rijen met lege responsen: hier krijg je dan per jaar een gemiddelde predictie Ã©n de se.
    result_stat_i <- I2$summary.linear.predictor %>% 
      slice(1:nrow(jaren)) %>% 
      bind_cols(jaren) %>% 
      mutate(intercept = I2$summary.fixed$mean) %>% 
      dplyr::select(-mode, -kld)    

        #gefitte waarden (deze zijn wel teruggetransformeteerd)    
    varname_mean <- paste0("p", percentile, "_mean", if (standardised == TRUE) ("_std"), "_fitted")
    varname_sd <- paste0("p", percentile, "_sd", if (standardised == TRUE) ("_std"), "_fitted")
    varname_p025 <- paste0("p", percentile, "_p02.5", if (standardised == TRUE) ("_std"), "_fitted")
    varname_p975 <- paste0("p", percentile, "_p97.5", if (standardised == TRUE) ("_std"), "_fitted")
    result_fitted_i <-  I2$summary.fitted.values %>% 
      rename(!!varname_mean := mean,
             !!varname_sd := sd,
             !!varname_p025 := '0.025quant',
             !!varname_p975 := '0.975quant')

    mdata <- bind_cols(mdata, result_fitted_i) %>% 
      slice(-(1:nrow(jaren))) #de regels met lege responsen hieruit verwijderen    
    
    if (standardised == TRUE) {
      varname_mean_backtransformed <- paste0(varname_mean, "_untr")
      varname_p025_backtransformed <- paste0(varname_p025, "_untr")
      varname_p975_backtransformed <- paste0(varname_p975, "_untr")
      result_fitted_i <- result_fitted_i %>% 
        mutate( !!varname_mean_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_mean),m,s),
                !!varname_p025_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_p025),m,s),
                !!varname_p975_backtransformed := unscale(result_fitted_i %>% 
                                                            dplyr::pull(!!varname_p975),m,s)    
        )
    }
    if (teller == 1) {
      result_stat <- result_stat_i
      result_fitted <- mdata
      
    } else {
      result_stat <- bind_rows(result_stat, 
                               result_stat_i)
      result_fitted <- bind_rows(result_fitted, mdata)    
    }
    
    if (teller == length(reeks)) {  
      result_stat <- result_stat %>% 
        rename( p02.5 = '0.025quant',
                p50 = '0.5quant',
                p97.5 = '0.975quant')
      
        if (standardised == TRUE) {
          result_stat <- result_stat %>% 
            mutate(mean_untr = unscale(mean, m, s),
                   og_berekend_untr = unscale(og_berekend, m, s),
                   bg_berekend_untr = unscale(bg_berekend, m, s),
                   p02.5_untr = unscale(p02.5, m, s),
                   p97.5_untr = unscale(p97.5, m, s),
                   se_berekend_untr = ((p97.5_untr  - mean_untr )/1.96 - 
                                         (p02.5_untr  - mean_untr )/1.96)/2,
            )
        }
      resultlijst <- list( result_stat, 
                           result_fitted)
      names(resultlijst) <- c(resultname_stat, resultname_fitted)
      list2env(resultlijst, envir = .GlobalEnv)
      
      if (varname_mean %in% colnames(dagen_droog)) {
        dagen_droog <- dagen_droog %>% 
          dplyr::select(-!!varname_mean, -!!varname_sd, -!!varname_p025, -!!varname_p975) 
      }
      
      dagen_droog <- dagen_droog %>% 
         inner_join(result_fitted %>% 
                      dplyr::select(contains("fitted"), 1:3), 
                    by = c("meetpunt","simulatienr", "jaar")) 
    }
  }
  return(dagen_droog)
}

```

```{r abs-indic-model-backup data}
dagen_droog_bu <- dagen_droog 
```

```{r abs-indic-model, include=FALSE}
#bij een eventuele herberekening moet de velden met de rekenresultaten eerst verwijderd worden
dagen_droog <- dagen_droog %>% 
  dplyr::select(-contains("fitted") )

modeldata <- dagen_droog


modelkeuze <- data.frame(percentiel = c("01", "05", "10", "30" ), model = c("zeroinflatednbinomial2", "zeroinflatednbinomial0", "zeroinflatednbinomial0", "nbinomial"))
modelkeuze$model <- as.character(modelkeuze$model)

#keuze van parameters
percentile <- "05"
indicatorname <- paste0("dag_onder_p",percentile)
indicatorname_inv <- paste0("dag_boven_p",percentile)
standardised <- FALSE
respons <- paste0(indicatorname, if (standardised == TRUE) ("_std"))


dagen_droog <- indic_abs_function(modeldata = modeldata, respons = respons, percentile = percentile, indicatorname = indicatorname, standardised = standardised)
```
```{r trend-data-vc, include=FALSE}

#bewaren resultaat
write_vc(dagen_droog, file.path("data", "result", "dagen_droog"), sorting = c("jaar", "meetpunt", "simulatienr"), strict = FALSE)

```

```{r trend-rubin}

#berekenen van indicator
indic_abs_gem <- dagen_droog %>% 
  group_by(jaar) %>% 
  summarise_at(vars(dag_onder_p01:dag_onder_p30), list(~mean(.), ~median(.))) %>% 
  ungroup


# rekening houden met multiple imputaties


droogte_trend_05 <- indic_abs_p05_jaar_stat %>% 
  group_by(jaar) %>% 
  summarise(gem_jaar_t = mean(mean),
            var_sim = sum(sd^2) / 20 + (1 + 1/20) * sum((mean - gem_jaar_t)^2)/(20 - 1),
            og_jaar_t = gem_jaar_t - 1.96 * sqrt(var_sim),
            bg_jaar_t = gem_jaar_t + 1.96 * sqrt(var_sim),
            gem_jaar = exp(gem_jaar_t),
            og_jaar = exp(og_jaar_t),
            bg_jaar = exp(bg_jaar_t)
  ) %>% 
  ungroup() %>% 
  inner_join(droogte_ind_j, by = "jaar")
```

Figuur \@ref(fig:trend-fitting-fig) geeft het resultaat van de modelbouw. 
De figuur toont de zowel de werkelijke waarden (punten) als de door het model geschatte waarden per meetpunt met hun betrouwbaarheidsinterval. 

```{r trend-fitting-fig-save, message=FALSE, warning=FALSE, include=FALSE}
fig <- plotfitting(indic_basis = dagen_droog, respons = "dag_onder_p05", gemid = "p05_mean_fitted", og = p05_p02.5_fitted, bg = p05_p97.5_fitted)
png(paste0(file.path("data","result", "figures","dagen_droog_p05"),"_tijdreeks",".png"))
fig
dev.off()

```

```{r trend-fitting-fig, fig.cap="gefitte waarden",  message=FALSE, warning=FALSE}
fig
```

Figuur \@ref(fig:trend-fig) geeft het finale resultaat: de droogte-indicatorwaarden en de trend met haar betrouwbaarheidsinterval. 
 
```{r trend-fig-save, fig.cap="trend", message=FALSE, warning=FALSE, include=FALSE}
#plot van de trend
gplot <- plottrend(droogte_trend_05,"droogte_ind_j", 18)
png(paste0(file.path("data","result", "figures","dagen_droog_p05"),"_trend",".png"))
gplot
dev.off()
```
 
```{r trend-fig, fig.cap="trend",  message=FALSE, warning=FALSE}
gplot
```


```{r trend-vc, include=FALSE}
#bewaren resultaten
write_vc(droogte_trend_05, file.path("data", "result", "droogte_trend_05"), sorting = c("jaar"), strict = FALSE)

write_vc(indic_abs_p05_jaar_stat, file.path("data", "result", "droogte_fitting_05"), sorting = c("jaar", "simulatienr"), strict = FALSE)
```


```{r trend-csv-voor-nara, include=FALSE}
#bewaren data voor figuur in nara
write_csv(droogte_trend_05 %>% dplyr::select(jaar, gem_jaar, og_jaar, bg_jaar, droogte_ind_j) %>% rename (`aantal dagen onder kritisch minimum`= droogte_ind_j), file.path("data", "result", "figuur_nara.csv"))
```


<!--chapter:end:03_Berekening.Rmd-->

# Referenties {-}
<!-- `r if (knitr::is_html_output()) {'# Bibliografie {-}'}` -->

<!--chapter:end:zzz_bibliografietitel.Rmd-->

